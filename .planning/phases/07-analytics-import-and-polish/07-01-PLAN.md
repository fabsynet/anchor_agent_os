---
phase: 07-analytics-import-and-polish
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/shared/src/constants/analytics.ts
  - packages/shared/src/types/analytics.ts
  - packages/shared/src/validation/analytics.schema.ts
  - packages/shared/src/validation/import.schema.ts
  - packages/shared/src/index.ts
  - packages/shared/src/constants/roles.ts
  - apps/api/src/analytics/analytics.module.ts
  - apps/api/src/analytics/analytics.controller.ts
  - apps/api/src/analytics/analytics.service.ts
  - apps/api/src/analytics/dto/analytics-query.dto.ts
  - apps/api/src/import/import.module.ts
  - apps/api/src/import/import.controller.ts
  - apps/api/src/import/import.service.ts
  - apps/api/src/import/dto/import-row.dto.ts
  - apps/api/src/app.module.ts
autonomous: true

must_haves:
  truths:
    - "Analytics API returns policy type breakdown grouped by type with counts and premium sums"
    - "Analytics API returns renewal pipeline data with monthly active/expiring/expired counts"
    - "Analytics API returns cross-sell opportunities identifying clients with coverage gaps"
    - "Analytics API returns client stats, expense summary, and compliance event counts"
    - "Import API accepts validated JSON rows and creates clients+policies with deduplication"
    - "Analytics nav item appears in sidebar for all users"
  artifacts:
    - path: "packages/shared/src/constants/analytics.ts"
      provides: "Cross-sell bundles, time range options, policy type mapping"
      contains: "CROSS_SELL_BUNDLES"
    - path: "packages/shared/src/types/analytics.ts"
      provides: "All analytics response types and import row types"
      exports: ["PolicyBreakdown", "RenewalPipelineMonth", "CrossSellOpportunity", "ImportResult"]
    - path: "apps/api/src/analytics/analytics.service.ts"
      provides: "All analytics aggregation queries"
      min_lines: 150
    - path: "apps/api/src/import/import.service.ts"
      provides: "Import with client dedup and batch create"
      min_lines: 80
    - path: "apps/api/src/app.module.ts"
      provides: "AnalyticsModule and ImportModule registered"
      contains: "AnalyticsModule"
  key_links:
    - from: "apps/api/src/analytics/analytics.service.ts"
      to: "prisma.policy.groupBy"
      via: "raw prisma with manual tenantId"
      pattern: "this\\.prisma\\.policy\\.groupBy"
    - from: "apps/api/src/import/import.service.ts"
      to: "prisma.$transaction"
      via: "batch create in transaction"
      pattern: "\\$transaction"
---

<objective>
Create the data foundation and complete backend API for Phase 7: analytics endpoints (7 report types), cross-sell intelligence engine, and CSV import endpoint with deduplication.

Purpose: Provides all API data that the analytics frontend and import wizard will consume. This is the foundation plan that unblocks all frontend work.
Output: Shared types/constants/validation, analytics NestJS module (8+ endpoints), import NestJS module (1 endpoint + template), NAV_ITEMS updated with Analytics entry.
</objective>

<execution_context>
@C:\Users\abuba\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\abuba\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-analytics-import-and-polish/07-CONTEXT.md
@.planning/phases/07-analytics-import-and-polish/07-RESEARCH.md
@packages/shared/src/index.ts
@packages/shared/src/constants/roles.ts
@packages/shared/src/constants/insurance.ts
@packages/shared/src/types/policy.ts
@packages/shared/src/types/client.ts
@apps/api/src/app.module.ts
@apps/api/src/dashboard/dashboard.service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Shared types, constants, validation schemas, and NAV_ITEMS update</name>
  <files>
    packages/shared/src/constants/analytics.ts
    packages/shared/src/types/analytics.ts
    packages/shared/src/validation/analytics.schema.ts
    packages/shared/src/validation/import.schema.ts
    packages/shared/src/index.ts
    packages/shared/src/constants/roles.ts
  </files>
  <action>
    1. Create `packages/shared/src/constants/analytics.ts`:
       - `CROSS_SELL_BUNDLES` array: `[{ name: 'Auto + Home', types: ['auto', 'home'] }, { name: 'Life + Health', types: ['life', 'health'] }, { name: 'Home + Umbrella', types: ['home', 'umbrella'] }]` (as const). Note: User said "Life+Disability" but schema uses 'health' type, not disability. Life+Health is the closest match per RESEARCH.md.
       - `MIN_POLICY_TYPES_FOR_CROSSSELL = 2`
       - `TIME_RANGES` array with values '3mo', '6mo', 'ytd', '12mo', 'all' and labels
       - `IMPORT_POLICY_TYPE_MAP`: lenient mapping object `{ automobile: 'auto', car: 'auto', house: 'home', homeowners: 'home', homeowner: 'home', ... }` covering common variations for all 8 policy types
       - `IMPORT_EXPECTED_FIELDS` array: `[{ key: 'firstName', label: 'First Name', required: true }, { key: 'lastName', label: 'Last Name', required: true }, { key: 'email', ... required: false }, { key: 'phone', ... }, { key: 'address', ... }, { key: 'city', ... }, { key: 'province', ... }, { key: 'postalCode', ... }, { key: 'policyType', label: 'Policy Type', required: true }, { key: 'carrier', ... }, { key: 'policyNumber', ... }, { key: 'premium', ... }, { key: 'startDate', label: 'Start Date', ... }, { key: 'endDate', label: 'End Date', ... }, { key: 'status', ... }]`

    2. Create `packages/shared/src/types/analytics.ts`:
       - `TimeRange = '3mo' | '6mo' | 'ytd' | '12mo' | 'all'`
       - `PolicyBreakdown = { type: string; count: number; totalPremium: number }`
       - `RenewalPipelineMonth = { month: string; active: number; expiring: number; expired: number }`
       - `CrossSellOpportunity = { clientId: string; clientName: string; activeTypes: string[]; gaps: string[]; fewPolicies: boolean }`
       - `ClientStats = { totalClients: number; activeClients: number; leads: number; newThisPeriod: number }`
       - `ExpenseSummary = { totalApproved: number; totalPending: number; byCategory: { category: string; amount: number }[]; budgetUsage: number | null }`
       - `ComplianceSummary = { totalEvents: number; byType: { type: string; count: number }[]; byUser: { userId: string; userName: string; count: number }[] }`
       - `OverviewStats = { totalClients: number; activePolicies: number; totalPremiumYtd: number; renewalRate: number }`
       - `ImportRow = { firstName: string; lastName: string; email?: string; phone?: string; address?: string; city?: string; province?: string; postalCode?: string; policyType: string; carrier?: string; policyNumber?: string; premium?: string; startDate?: string; endDate?: string; status?: string }`
       - `ImportResult = { clientsCreated: number; policiesCreated: number; duplicatesSkipped: number; duplicates: { firstName: string; lastName: string; email?: string; existingId: string }[]; errors: { row: number; message: string }[] }`

    3. Create `packages/shared/src/validation/analytics.schema.ts`:
       - `analyticsQuerySchema` with optional `startDate` (ISO string), optional `endDate` (ISO string), optional `timeRange` (enum of TimeRange values)
       - Export `AnalyticsQueryInput` type

    4. Create `packages/shared/src/validation/import.schema.ts`:
       - `importRowSchema` validating individual row: firstName (min 1), lastName (min 1), email (optional, email format), phone (optional), policyType (min 1), carrier (optional), policyNumber (optional), premium (optional, coerce to string), startDate (optional), endDate (optional)
       - `importBatchSchema` with `rows` array of importRowSchema (min 1, max 5000)
       - Export `ImportRowInput`, `ImportBatchInput` types

    5. Update `packages/shared/src/constants/roles.ts`:
       - Add Analytics entry to NAV_ITEMS array, positioned AFTER expenses and BEFORE settings: `{ id: 'analytics', label: 'Analytics', href: '/analytics', icon: 'BarChart3', adminOnly: false }`
       - This means ALL users (admin + agent) can access analytics per the pattern (it is not adminOnly)

    6. Update `packages/shared/src/index.ts`:
       - Export all new types from types/analytics.ts
       - Export all new constants from constants/analytics.ts
       - Export validation schemas and types from validation/analytics.schema.ts and validation/import.schema.ts
  </action>
  <verify>
    Run `pnpm --filter @anchor/shared build` (or `pnpm --filter shared build` depending on package name) to confirm no type errors. Verify exports are accessible.
  </verify>
  <done>
    All analytics types, constants (CROSS_SELL_BUNDLES, TIME_RANGES, IMPORT_POLICY_TYPE_MAP, IMPORT_EXPECTED_FIELDS), validation schemas (analyticsQuerySchema, importRowSchema, importBatchSchema), and NAV_ITEMS update are exported from @anchor/shared. Build passes cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Analytics NestJS module with all report endpoints</name>
  <files>
    apps/api/src/analytics/analytics.module.ts
    apps/api/src/analytics/analytics.controller.ts
    apps/api/src/analytics/analytics.service.ts
    apps/api/src/analytics/dto/analytics-query.dto.ts
    apps/api/src/app.module.ts
  </files>
  <action>
    1. Create `apps/api/src/analytics/dto/analytics-query.dto.ts`:
       - DTO class with optional `startDate?: string`, `endDate?: string` query params
       - Use class-validator decorators (@IsOptional, @IsDateString)

    2. Create `apps/api/src/analytics/analytics.service.ts`:
       - Inject PrismaService (same pattern as dashboard.service.ts)
       - Import date-fns: startOfMonth, endOfMonth, subMonths, startOfYear, startOfDay, format
       - CRITICAL: All queries use raw `this.prisma` (NOT tenantClient) with manual `tenantId` in where clause, because groupBy/aggregate/count are NOT overridden by tenant extension
       - CRITICAL: Always `Number(result._sum.premium ?? 0)` for Decimal aggregate results

       **Method: getOverview(tenantId, startDate?, endDate?)**
       - Returns OverviewStats: totalClients (count), activePolicies (count where status in active/pending_renewal), totalPremiumYtd (aggregate sum premium for current year), renewalRate (count renewed / count of all expiring+renewed in period, as percentage)
       - Use Promise.all for parallel queries

       **Method: getPolicyBreakdown(tenantId, startDate?, endDate?)**
       - Returns PolicyBreakdown[]: groupBy type with _count and _sum premium
       - Filter by date range on createdAt if provided
       - Map results: `{ type, count: _count.id, totalPremium: Number(_sum.premium ?? 0) }`

       **Method: getClientStats(tenantId, startDate?, endDate?)**
       - Returns ClientStats: total clients, active (status='client'), leads (status='lead'), new this period (createdAt in date range)
       - 4 parallel count queries

       **Method: getRenewalPipeline(tenantId, months = 12)**
       - Returns RenewalPipelineMonth[]: for each of last N months, count active/expiring/expired policies
       - Follow exact pattern from RESEARCH.md code example
       - Use startOfMonth/endOfMonth per month, 3 parallel counts per month
       - Use Promise.all to parallelize all months

       **Method: getExpenseSummary(tenantId, startDate?, endDate?)**
       - Returns ExpenseSummary: aggregate approved expenses, pending expenses, groupBy category for approved, budget usage from current month budget
       - Use BudgetsService.findCurrentMonth for budget data (inject BudgetsService)

       **Method: getComplianceSummary(tenantId, startDate?, endDate?)**
       - Returns ComplianceSummary: count activity events total, groupBy type, groupBy userId (with user lookup for names)
       - groupBy on activityEvent model with tenantId + date filter

       **Method: getCrossSellOpportunities(tenantId)**
       - Returns CrossSellOpportunity[]: follow exact RESEARCH.md pattern
       - Find all clients with status='client' and include their active policies (status in active/pending_renewal)
       - For each client: check CROSS_SELL_BUNDLES (import from shared constants or inline -- API doesn't have @anchor/shared dep, so INLINE the 3 bundles and MIN_POLICY_TYPES constant per Phase 6 pattern "Badge constants inlined in API service")
       - Return only clients with gaps (hasGaps = true)

       **Method: getPremiumByProductLine(tenantId, startDate?, endDate?)**
       - Returns array of { type, customType, count, totalPremium }
       - groupBy ['type'] for standard types, then for type='other' do a second groupBy on ['type', 'customType']
       - This fulfills the "Premium report by product line and policy sub-type" requirement

       **Helper: buildDateFilter(startDate?, endDate?, field = 'createdAt')**
       - Returns Prisma where clause fragment for date range filtering
       - Used across all methods for consistency

    3. Create `apps/api/src/analytics/analytics.controller.ts`:
       - @Controller('analytics'), @UseGuards(JwtAuthGuard)
       - Import TenantId decorator (same as other controllers)
       - 8 GET endpoints:
         - `GET /analytics/overview` -> getOverview
         - `GET /analytics/policy-breakdown` -> getPolicyBreakdown
         - `GET /analytics/client-stats` -> getClientStats
         - `GET /analytics/renewal-pipeline` -> getRenewalPipeline
         - `GET /analytics/expense-summary` -> getExpenseSummary
         - `GET /analytics/compliance-summary` -> getComplianceSummary
         - `GET /analytics/cross-sell` -> getCrossSellOpportunities
         - `GET /analytics/premium-by-product` -> getPremiumByProductLine
       - All endpoints accept @Query() AnalyticsQueryDto (except cross-sell which has no date filter)

    4. Create `apps/api/src/analytics/analytics.module.ts`:
       - Import PrismaModule, BudgetsModule (for expense summary budget data)
       - Provide and export AnalyticsService, AnalyticsController

    5. Update `apps/api/src/app.module.ts`:
       - Import and add AnalyticsModule to imports array
       - Follow the existing pattern of import statement + array entry
  </action>
  <verify>
    Run `pnpm --filter api build` to verify TypeScript compilation passes. Check that all 8 endpoints are registered by reviewing the controller.
  </verify>
  <done>
    Analytics module with 8 endpoints is registered and compiles. All queries use raw prisma with manual tenantId. Decimal values are converted with Number(). Promise.all is used for parallel queries. Date range filtering works across all endpoints.
  </done>
</task>

<task type="auto">
  <name>Task 3: Import NestJS module with batch create and deduplication</name>
  <files>
    apps/api/src/import/import.module.ts
    apps/api/src/import/import.controller.ts
    apps/api/src/import/import.service.ts
    apps/api/src/import/dto/import-row.dto.ts
    apps/api/src/app.module.ts
  </files>
  <action>
    1. Create `apps/api/src/import/dto/import-row.dto.ts`:
       - `ImportRowDto` class with fields: firstName, lastName, email?, phone?, address?, city?, province?, postalCode?, policyType, carrier?, policyNumber?, premium?, startDate?, endDate?, status?
       - `ImportBatchDto` class with `rows: ImportRowDto[]` array
       - Use class-validator decorators: @IsString, @IsOptional, @IsArray, @ValidateNested, @Type(() => ImportRowDto)

    2. Create `apps/api/src/import/import.service.ts`:
       - Inject PrismaService and TimelineService (for activity events on created clients/policies)
       - CRITICAL: Inline the IMPORT_POLICY_TYPE_MAP for lenient type matching (API cannot import from @anchor/shared)

       **Method: importClientsAndPolicies(tenantId, userId, rows: ImportRowDto[])**
       - Step 1: Group rows by client using normalized key: `normalize(firstName + lastName + email)`. Normalize = lowercase, trim, remove extra whitespace.
       - Step 2: Load existing clients for this tenant (findMany with select: id, firstName, lastName, email)
       - Step 3: Use `$transaction` to batch create:
         - For each unique client:
           - Check if existing client matches (normalized name + email comparison)
           - If duplicate: skip client creation, use existing clientId, add to duplicates array
           - If new: create client via `tx.client.create({ data: { firstName, lastName, email, phone, address, city, province, postalCode, tenantId, createdById: userId, status: 'client' } })`
         - For each policy row within that client:
           - Map policyType through lenient mapping (e.g., 'automobile' -> 'auto'). If unrecognized, default to 'other'.
           - Parse premium as Decimal if provided
           - Parse startDate/endDate as Date if provided (handle common formats: YYYY-MM-DD, MM/DD/YYYY, DD/MM/YYYY)
           - Map status: default to 'active' if not provided; lenient map for values like 'Active', 'Expired', etc.
           - Create policy via `tx.policy.create({ data: { type, carrier, policyNumber, premium, startDate, endDate, status, tenantId, clientId, createdById: userId } })`
         - Wrap individual row operations in try/catch; on error, add to errors array with row number and message, continue with next row
       - Step 4: Return ImportResult: { clientsCreated, policiesCreated, duplicatesSkipped, duplicates, errors }
       - Use batches of 50 rows within the transaction to avoid memory pressure (process 50 clients at a time within the same tx)

       **Method: getTemplate()**
       - Return an array of header strings matching IMPORT_EXPECTED_FIELDS keys
       - Return 2 example rows with realistic sample data (Canadian names, policy types, CAD premiums)
       - Format as CSV string using simple join (no PapaParse on backend)

    3. Create `apps/api/src/import/import.controller.ts`:
       - @Controller('import'), @UseGuards(JwtAuthGuard)
       - `POST /import/clients-policies` -> accepts ImportBatchDto body, calls importClientsAndPolicies
         - Extract tenantId from @TenantId() decorator, userId from request user
         - Returns ImportResult
       - `GET /import/template` -> returns CSV template string with Content-Type text/csv header
         - Set response header: `res.setHeader('Content-Type', 'text/csv')` and `res.setHeader('Content-Disposition', 'attachment; filename="anchor-import-template.csv"')`
         - Use @Res() decorator with passthrough: true, or return the string with proper headers

    4. Create `apps/api/src/import/import.module.ts`:
       - Import PrismaModule, TimelineModule (for activity event creation after import)
       - Provide ImportService, ImportController

    5. Update `apps/api/src/app.module.ts`:
       - Import and add ImportModule to imports array (if not already done in Task 2)
  </action>
  <verify>
    Run `pnpm --filter api build` to verify TypeScript compilation passes. Verify the controller has 2 endpoints (POST and GET).
  </verify>
  <done>
    Import module with POST /import/clients-policies (batch create with dedup) and GET /import/template (CSV template download) is registered and compiles. Deduplication uses normalized name+email matching. Lenient policy type mapping handles common variations. Errors per row are captured without aborting the entire import. Transaction batches of 50 prevent memory pressure.
  </done>
</task>

</tasks>

<verification>
1. `pnpm --filter @anchor/shared build` passes -- all types, constants, and validation schemas compile
2. `pnpm --filter api build` passes -- both AnalyticsModule and ImportModule compile and register
3. NAV_ITEMS in roles.ts includes Analytics entry before Settings
4. Analytics controller has 8 GET endpoints
5. Import controller has POST /import/clients-policies and GET /import/template
6. All analytics queries use raw `this.prisma` with manual tenantId (NOT tenantClient for groupBy/aggregate/count)
</verification>

<success_criteria>
- Shared package exports all analytics types (PolicyBreakdown, RenewalPipelineMonth, CrossSellOpportunity, etc.), constants (CROSS_SELL_BUNDLES, TIME_RANGES, IMPORT_POLICY_TYPE_MAP), and validation schemas
- Analytics API: 8 endpoints returning aggregated data with date range filtering
- Import API: batch import with client deduplication and lenient type mapping
- NAV_ITEMS updated with Analytics entry for all users
- Both API modules registered in AppModule and building cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/07-analytics-import-and-polish/07-01-SUMMARY.md`
</output>
