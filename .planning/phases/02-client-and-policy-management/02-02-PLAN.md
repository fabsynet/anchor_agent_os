---
phase: 02-client-and-policy-management
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - apps/api/src/clients/clients.module.ts
  - apps/api/src/clients/clients.controller.ts
  - apps/api/src/clients/clients.service.ts
  - apps/api/src/clients/dto/create-client.dto.ts
  - apps/api/src/clients/dto/update-client.dto.ts
  - apps/api/src/clients/dto/search-clients.dto.ts
  - apps/api/src/timeline/timeline.module.ts
  - apps/api/src/timeline/timeline.controller.ts
  - apps/api/src/timeline/timeline.service.ts
  - apps/api/src/timeline/dto/create-note.dto.ts
  - apps/api/src/policies/policies.module.ts
  - apps/api/src/policies/policies.controller.ts
  - apps/api/src/policies/policies.service.ts
  - apps/api/src/policies/dto/create-policy.dto.ts
  - apps/api/src/policies/dto/update-policy.dto.ts
  - apps/api/src/app.module.ts
autonomous: true

must_haves:
  truths:
    - "GET /api/clients returns paginated, searchable, filterable client list"
    - "POST /api/clients creates a client with lead/client validation"
    - "PATCH /api/clients/:id/convert toggles between lead and client status"
    - "GET /api/clients/:clientId/timeline returns chronological activity events including notes"
    - "POST /api/clients/:clientId/notes creates an immutable note and logs a timeline event"
    - "POST /api/clients/:clientId/policies creates a policy and auto-converts lead to client"
    - "Policy status transitions are validated (no invalid transitions like cancelled -> active)"
    - "All queries are tenant-scoped via this.prisma.tenantClient"
  artifacts:
    - path: "apps/api/src/clients/clients.controller.ts"
      provides: "Client CRUD + search + convert endpoints"
      exports: ["ClientsController"]
    - path: "apps/api/src/clients/clients.service.ts"
      provides: "Client business logic with tenant-scoped queries"
      exports: ["ClientsService"]
    - path: "apps/api/src/timeline/timeline.service.ts"
      provides: "Activity event creation and timeline listing"
      exports: ["TimelineService"]
    - path: "apps/api/src/policies/policies.service.ts"
      provides: "Policy CRUD with status transition validation and auto-convert"
      exports: ["PoliciesService"]
    - path: "apps/api/src/app.module.ts"
      provides: "All 3 new modules registered"
      contains: "ClientsModule"
  key_links:
    - from: "apps/api/src/policies/policies.service.ts"
      to: "apps/api/src/clients/clients.service.ts"
      via: "auto-convert lead on first policy creation"
      pattern: "auto.*convert|status.*client"
    - from: "apps/api/src/clients/clients.service.ts"
      to: "apps/api/src/timeline/timeline.service.ts"
      via: "creates activity events on mutations"
      pattern: "createActivityEvent|timelineService"
    - from: "apps/api/src/policies/policies.service.ts"
      to: "apps/api/src/timeline/timeline.service.ts"
      via: "creates activity events on policy mutations"
      pattern: "createActivityEvent|timelineService"
---

<objective>
Build all three NestJS backend modules for Phase 2: ClientsModule (CRUD, search, status conversion), TimelineModule (activity events, notes), and PoliciesModule (CRUD, status transitions, auto-convert). All follow the established InvitationsModule pattern.

Purpose: The frontend plans (02-03, 02-04, 02-05) need working API endpoints to fetch and mutate data.
Output: Three NestJS modules with full CRUD endpoints, tenant-scoped queries, activity event logging, and policy status machine.
</objective>

<execution_context>
@C:\Users\abuba\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\abuba\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-client-and-policy-management/02-CONTEXT.md
@.planning/phases/02-client-and-policy-management/02-RESEARCH.md
@.planning/phases/02-client-and-policy-management/02-01-SUMMARY.md
@apps/api/src/invitations/invitations.controller.ts
@apps/api/src/invitations/invitations.service.ts
@apps/api/src/invitations/invitations.module.ts
@apps/api/src/app.module.ts
@apps/api/src/common/prisma/prisma.service.ts
@apps/api/src/common/prisma/prisma-tenant.extension.ts
@apps/api/src/auth/guards/jwt-auth.guard.ts
@apps/api/src/auth/decorators/current-user.decorator.ts
@apps/api/src/auth/decorators/tenant-id.decorator.ts
@apps/api/src/auth/decorators/roles.decorator.ts
@packages/shared/src/types/client.ts
@packages/shared/src/types/policy.ts
@packages/shared/src/types/activity.ts
@packages/shared/src/constants/insurance.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: ClientsModule — CRUD, search, filter, status conversion</name>
  <files>
    apps/api/src/clients/clients.module.ts
    apps/api/src/clients/clients.controller.ts
    apps/api/src/clients/clients.service.ts
    apps/api/src/clients/dto/create-client.dto.ts
    apps/api/src/clients/dto/update-client.dto.ts
    apps/api/src/clients/dto/search-clients.dto.ts
  </files>
  <action>
Create the ClientsModule following the exact InvitationsModule pattern. Use `@UseGuards(JwtAuthGuard, RolesGuard)` at class level. All queries use `this.prisma.tenantClient` (NOT raw `this.prisma`). Use `findFirst` instead of `findUnique` for single-record lookups (tenant extension doesn't override findUnique).

**DTOs (class-validator):**

`CreateClientDto`: firstName (@IsString, @MinLength(1)), lastName (@IsString, @MinLength(1)), email (@IsOptional, @IsEmail), phone (@IsOptional, @IsString), status (@IsEnum(['lead', 'client'])), address/city/province/postalCode (@ValidateIf status === 'client', @IsString), dateOfBirth (@IsOptional, @IsDateString). Add custom validation: if status is 'lead', must have email OR phone (use @ValidateIf or custom validator).

`UpdateClientDto`: Same fields as Create but all @IsOptional. Use PartialType from @nestjs/mapped-types if available, otherwise manually make all optional.

`SearchClientsDto`: For query params. status (@IsOptional, @IsEnum(['lead', 'client'])), search (@IsOptional, @IsString, for name/email/phone search), page (@IsOptional, @Type(() => Number), @IsInt, @Min(1), default 1), limit (@IsOptional, @Type(() => Number), @IsInt, @Min(1), @Max(100), default 20). Use @Transform and @Type decorators for query param parsing.

**Controller endpoints:**

```
POST   /api/clients          — create(tenantId, user, dto)
GET    /api/clients          — findAll(tenantId, query: SearchClientsDto)
GET    /api/clients/:id      — findOne(tenantId, id)
PATCH  /api/clients/:id      — update(tenantId, id, dto)
DELETE /api/clients/:id      — remove(tenantId, id)
PATCH  /api/clients/:id/convert — convert(tenantId, user, id)
```

Use @TenantId(), @CurrentUser(), @Param('id', ParseUUIDPipe), @Query(), @Body() decorators matching the invitations pattern.

**Service methods:**

`create(tenantId, userId, dto)`:
- Use `this.prisma.tenantClient.client.create()`. The tenant extension auto-injects tenantId.
- Set `createdById: userId`.
- Return the created client.

`findAll(tenantId, query)`:
- Use `this.prisma.tenantClient.client.findMany()`.
- Apply search filter: if query.search exists, use Prisma `OR` with `contains` (mode: 'insensitive') on firstName, lastName, email, phone.
- Apply status filter: if query.status exists, add to where clause.
- Pagination: `skip: (page - 1) * limit`, `take: limit`.
- Include `_count: { policies: true }` for policyCount.
- Include policies with `select: { endDate: true, status: true }` to compute nextRenewalDate.
- Order by lastName, firstName ascending.
- Return `{ data: clients, total, page, limit, totalPages }` with `this.prisma.tenantClient.client.count()` for total.
- Map results to include policyCount and nextRenewalDate (earliest future endDate where status is 'active' or 'pending_renewal').

`findOne(tenantId, id)`:
- Use `this.prisma.tenantClient.client.findFirst({ where: { id } })`.
- Include `policies: true` and `_count: { policies: true, notes: true, activityEvents: true }`.
- Throw NotFoundException if not found.

`update(tenantId, id, dto)`:
- Use `this.prisma.tenantClient.client.findFirst({ where: { id } })` to verify exists.
- Use `this.prisma.tenantClient.client.update()` with `where: { id }` -- NOTE: tenant extension overrides update to add tenantId to where.
- Actually, since update uses the tenant extension which adds tenantId, we cannot use `update` with just `where: { id }` because update expects a unique identifier. Instead, first findFirst to confirm existence, then use raw prisma with ID lookup but verify tenantId matches. OR use `updateMany` which the tenant extension can handle. BETTER APPROACH: use `this.prisma.tenantClient.client.updateMany({ where: { id }, data: dto })` then return the updated record via findFirst. This is the safe pattern with tenant extension.

Wait -- the tenant extension DOES override `update` (see prisma-tenant.extension.ts). It adds tenantId to args.where. But Prisma `update` requires a unique where (like `{ id }`). Adding `{ id, tenantId }` to the where might cause issues since the compound isn't unique-constrained. Actually, Prisma `update` does work with additional where fields beyond the @id if they're added programmatically. The extension adds tenantId to the where object, and Prisma's update actually accepts any combination including non-unique fields as long as an @id or @unique field is present. This works.

So: Use `this.prisma.tenantClient.client.update({ where: { id }, data: dto })`. The extension adds tenantId, making it `{ id, tenantId }`. If the record doesn't belong to this tenant, Prisma will throw a NotFound error. Catch and rethrow as NotFoundException.

`remove(tenantId, id)`:
- Same pattern: findFirst to verify, then delete. Use `this.prisma.tenantClient.client.delete({ where: { id } })`.
- Cascade will handle policies, activity events, notes.

`convert(tenantId, userId, id)`:
- findFirst to get current client.
- Toggle status: if 'lead' -> 'client', if 'client' -> 'lead'.
- If converting to 'client', validate that all required client fields exist (email, phone, address, city, province, postalCode). If missing, throw BadRequestException listing missing fields.
- If converting to 'lead', no validation needed (relaxing requirements).
- Update the status.
- Return updated client.

NOTE: Do NOT inject TimelineService yet. Activity event creation will be wired in Task 2 when TimelineModule is built. For now, focus on pure CRUD. The service will be updated to inject TimelineService in Task 2.

**Module:**
Standard NestJS module exporting ClientsService (needed by PoliciesModule for auto-convert).
  </action>
  <verify>
Run `pnpm --filter api build` -- should compile with zero TypeScript errors.
Verify all 6 endpoints are defined in the controller.
Verify service uses `this.prisma.tenantClient` for all queries (not raw `this.prisma`).
Verify SearchClientsDto has @Type(() => Number) decorators for page/limit query params.
  </verify>
  <done>
ClientsModule has full CRUD (create, findAll, findOne, update, remove) plus convert endpoint. Search supports name/email/phone text search and status filtering. Pagination returns total count. Tenant isolation enforced via tenantClient.
  </done>
</task>

<task type="auto">
  <name>Task 2: TimelineModule, PoliciesModule, wire activity events, register all in AppModule</name>
  <files>
    apps/api/src/timeline/timeline.module.ts
    apps/api/src/timeline/timeline.controller.ts
    apps/api/src/timeline/timeline.service.ts
    apps/api/src/timeline/dto/create-note.dto.ts
    apps/api/src/policies/policies.module.ts
    apps/api/src/policies/policies.controller.ts
    apps/api/src/policies/policies.service.ts
    apps/api/src/policies/dto/create-policy.dto.ts
    apps/api/src/policies/dto/update-policy.dto.ts
    apps/api/src/clients/clients.module.ts
    apps/api/src/clients/clients.service.ts
    apps/api/src/app.module.ts
  </files>
  <action>
**Part A: TimelineModule**

`CreateNoteDto`: content (@IsString, @MinLength(1), @MaxLength(5000)).

`TimelineService`:
- Inject PrismaService.
- `createActivityEvent(tenantId, clientId, userId, type: ActivityEventType string, description: string, metadata?: Record<string, unknown>)`: Create an ActivityEvent record. Use raw `this.prisma` (not tenantClient) since we explicitly pass tenantId as data. Actually, use `this.prisma.tenantClient.activityEvent.create()` which auto-injects tenantId -- but we still pass clientId, userId, type, description, metadata. Metadata should be stored as JSON (Prisma Json type).
- `getTimeline(tenantId, clientId: string, page: number, limit: number)`: Fetch activity events + notes for a client, merged and sorted by createdAt descending. Approach: fetch activityEvents and notes separately, merge and sort in memory, paginate. Include user relation (select firstName, lastName) on both. Return `{ data: [...events, ...notes], total, page, limit }`. Each item should have a `kind` field ('event' | 'note') added in the response to distinguish them.
- `createNote(tenantId, clientId: string, userId: string, content: string)`: Create a Note record. Then create an ActivityEvent of type 'note_added' with description "Added a note". Return the note.

`TimelineController`:
```
GET  /api/clients/:clientId/timeline  — getTimeline(tenantId, clientId, page, limit)
POST /api/clients/:clientId/notes     — createNote(tenantId, user, clientId, content)
```
Use @UseGuards(JwtAuthGuard, RolesGuard) at class level. Use @Param('clientId', ParseUUIDPipe).

`TimelineModule`: Import PrismaModule (global, but explicit for clarity). Export TimelineService so other modules can inject it.

**Part B: PoliciesModule**

`CreatePolicyDto`: type (@IsEnum of PolicyType values), customType (@IsOptional, @IsString, @ValidateIf type === 'other'), carrier (@IsOptional, @IsString), policyNumber (@IsOptional, @IsString), startDate (@IsOptional, @IsDateString), endDate (@IsOptional, @IsDateString), premium (@IsOptional, @IsString -- Decimal as string), coverageAmount (@IsOptional, @IsString), deductible (@IsOptional, @IsString), paymentFrequency (@IsOptional, @IsEnum), brokerCommission (@IsOptional, @IsString), status (@IsOptional, @IsEnum of PolicyStatus values, default 'draft'), notes (@IsOptional, @IsString).

`UpdatePolicyDto`: All fields from CreatePolicyDto but @IsOptional.

`PoliciesService`:
- Inject PrismaService, TimelineService, and ClientsService (for auto-convert check).
- Define VALID_TRANSITIONS map:
  ```
  draft -> [active]
  active -> [pending_renewal, cancelled, expired]
  pending_renewal -> [renewed, expired, cancelled]
  renewed -> [active]
  expired -> [] (terminal)
  cancelled -> [] (terminal)
  ```
- `create(tenantId, clientId, userId, dto)`:
  - Verify client exists via findFirst.
  - Use `this.prisma.$transaction()` to atomically:
    1. Create policy via tenantClient.
    2. Check if client is 'lead' and this is their first policy: if so, update client status to 'client'. Create activity event for status change.
    3. Create activity event for 'policy_created'.
  - Return the created policy.
  - For Decimal fields (premium, coverageAmount, deductible, brokerCommission): pass the string value directly to Prisma -- it handles string-to-Decimal conversion.

- `findAll(tenantId, clientId)`: Find all policies for a client. Include client relation (just id, firstName, lastName for display). Order by createdAt desc.

- `findOne(tenantId, clientId, id)`: findFirst with { id, clientId }. Throw NotFoundException if not found.

- `update(tenantId, clientId, id, userId, dto)`:
  - findFirst to get current policy.
  - If dto.status and dto.status !== current status: validate transition using VALID_TRANSITIONS map. If invalid, throw BadRequestException with message about allowed transitions.
  - Update the policy.
  - If status changed, create 'policy_status_changed' activity event with metadata: { from: oldStatus, to: newStatus }.
  - If other fields changed, create 'policy_updated' activity event.
  - Return updated policy.

- `remove(tenantId, clientId, id, userId)`: findFirst to verify, delete the policy. Create 'policy_deleted' activity event with metadata about the deleted policy.

`PoliciesController`:
```
GET    /api/clients/:clientId/policies        — findAll(tenantId, clientId)
POST   /api/clients/:clientId/policies        — create(tenantId, user, clientId, dto)
GET    /api/clients/:clientId/policies/:id     — findOne(tenantId, clientId, id)
PATCH  /api/clients/:clientId/policies/:id     — update(tenantId, user, clientId, id, dto)
DELETE /api/clients/:clientId/policies/:id     — remove(tenantId, user, clientId, id)
```
Use @Param('clientId', ParseUUIDPipe) and @Param('id', ParseUUIDPipe).

`PoliciesModule`: Import ClientsModule (for ClientsService), TimelineModule (for TimelineService).

**Part C: Wire activity events into ClientsService**

Update `ClientsModule` to import TimelineModule. Update `ClientsService` to inject `TimelineService`.

Add activity event creation calls to ClientsService:
- `create()`: After creating client, call `this.timelineService.createActivityEvent(tenantId, client.id, userId, 'client_created', 'Client created')`.
- `update()`: After updating, call with 'client_updated' type. Include metadata with changed fields.
- `convert()`: After status toggle, call with 'client_status_changed' type. Include metadata `{ from: oldStatus, to: newStatus }`.
- `remove()`: Before deleting (since cascade removes events too), log the action. Actually, since cascade removes the events, logging a deletion event for the client doesn't persist. Skip deletion logging or log to a separate audit table (out of scope -- skip for now per simplicity).

**Part D: Register all modules in AppModule**

Update `apps/api/src/app.module.ts` to import ClientsModule, TimelineModule, PoliciesModule.

**CRITICAL PATTERNS:**
- Use `.js` extension on all relative imports (NestJS ESM convention in this project). Example: `import { TimelineService } from '../timeline/timeline.service.js';`
- Use `this.prisma.tenantClient` for ALL queries, never raw `this.prisma` (except in $transaction which uses the raw client -- the transaction callback receives a prisma instance that should NOT be extended).
- Actually, $transaction with the interactive API (`this.prisma.$transaction(async (tx) => {...})`) receives a transaction client. You CANNOT use tenantClient inside a $transaction because the extension creates a new client. Instead, manually add tenantId to where clauses inside $transaction. Use this pattern:
  ```typescript
  const tenantId = this.cls.get('tenantId'); // or pass tenantId as parameter
  await this.prisma.$transaction(async (tx) => {
    await tx.policy.create({ data: { ...dto, tenantId, clientId, createdById: userId } });
    await tx.client.updateMany({ where: { id: clientId, tenantId }, data: { status: 'client' } });
  });
  ```
- For the $transaction approach: inject ClsService into PoliciesService to get tenantId, OR just accept tenantId as a parameter from the controller (already done via @TenantId decorator). Passing tenantId as parameter is cleaner.
  </action>
  <verify>
Run `pnpm --filter api build` -- should compile with zero TypeScript errors.
Verify AppModule imports all 3 new modules (ClientsModule, TimelineModule, PoliciesModule).
Verify PoliciesService has VALID_TRANSITIONS map and validates status transitions.
Verify PoliciesService.create() uses $transaction for atomic policy creation + auto-convert.
Verify TimelineService.getTimeline() merges events and notes with 'kind' discriminator.
Verify all controllers use @UseGuards(JwtAuthGuard, RolesGuard).
Verify all relative imports use .js extension.
  </verify>
  <done>
Three NestJS modules fully operational:
- ClientsModule: CRUD + search + convert with activity event logging
- TimelineModule: Timeline listing (merged events + notes) and note creation
- PoliciesModule: CRUD with status transition validation, auto-convert lead on first policy, activity event logging
All registered in AppModule. All queries tenant-scoped. Policy creation atomic via $transaction.
  </done>
</task>

</tasks>

<verification>
- `pnpm --filter api build` compiles with zero errors
- All 3 modules registered in AppModule
- Client endpoints: POST, GET (list), GET (single), PATCH, DELETE, PATCH convert
- Timeline endpoints: GET timeline, POST note
- Policy endpoints: POST, GET (list), GET (single), PATCH, DELETE
- All use JwtAuthGuard + tenantClient
- Policy status transitions validated
- Auto-convert lead to client on first policy
- Activity events created for all mutations
</verification>

<success_criteria>
- 13 API endpoints across 3 modules, all compiling and following established patterns
- Tenant isolation enforced on every query
- Policy status machine prevents invalid transitions
- Auto-convert uses $transaction for atomicity
- Activity events logged for: client_created, client_updated, client_status_changed, note_added, policy_created, policy_updated, policy_status_changed, policy_deleted
</success_criteria>

<output>
After completion, create `.planning/phases/02-client-and-policy-management/02-02-SUMMARY.md`
</output>
