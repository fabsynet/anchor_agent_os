---
phase: 04-documents-and-compliance
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - apps/api/src/documents/documents.module.ts
  - apps/api/src/documents/documents.controller.ts
  - apps/api/src/documents/documents.service.ts
  - apps/api/src/documents/dto/upload-document.dto.ts
  - apps/api/src/documents/dto/search-documents.dto.ts
  - apps/api/src/compliance/compliance.module.ts
  - apps/api/src/compliance/compliance.controller.ts
  - apps/api/src/compliance/compliance.service.ts
  - apps/api/src/compliance/dto/search-compliance.dto.ts
  - apps/api/src/app.module.ts
  - apps/api/src/timeline/timeline.service.ts
autonomous: true

must_haves:
  truths:
    - "POST /api/clients/:clientId/documents accepts multipart upload and stores files in Supabase Storage"
    - "GET /api/clients/:clientId/documents returns documents list filtered by policyId/category"
    - "GET /api/clients/:clientId/documents/:documentId/url returns a time-limited signed URL"
    - "DELETE /api/clients/:clientId/documents/:documentId removes file from storage and Prisma record"
    - "Document upload and delete automatically create activity events"
    - "GET /api/compliance returns paginated, filtered activity events across all clients"
    - "Compliance endpoint filters by clientId, type, userId, policyId, date range"
  artifacts:
    - path: "apps/api/src/documents/documents.controller.ts"
      provides: "Document REST endpoints (upload, list, get URL, delete)"
      exports: ["DocumentsController"]
    - path: "apps/api/src/documents/documents.service.ts"
      provides: "Document business logic with Supabase Storage operations"
      exports: ["DocumentsService"]
    - path: "apps/api/src/compliance/compliance.controller.ts"
      provides: "Compliance query endpoint with filters"
      exports: ["ComplianceController"]
    - path: "apps/api/src/compliance/compliance.service.ts"
      provides: "Compliance query logic against ActivityEvent"
      exports: ["ComplianceService"]
  key_links:
    - from: "apps/api/src/documents/documents.service.ts"
      to: "Supabase Storage"
      via: "createSupabaseAdmin from common/config/supabase.config.js"
      pattern: "supabaseAdmin\\.storage\\.from\\('documents'\\)"
    - from: "apps/api/src/documents/documents.service.ts"
      to: "apps/api/src/timeline/timeline.service.ts"
      via: "TimelineService.createActivityEvent for document_uploaded/document_deleted"
      pattern: "timelineService\\.createActivityEvent"
    - from: "apps/api/src/compliance/compliance.service.ts"
      to: "Prisma activityEvent"
      via: "Direct Prisma query with filters"
      pattern: "prisma\\.activityEvent\\.findMany"
    - from: "apps/api/src/app.module.ts"
      to: "DocumentsModule, ComplianceModule"
      via: "Module imports array"
      pattern: "DocumentsModule|ComplianceModule"
---

<objective>
Create NestJS backend modules for document management (upload, list, signed URL, delete) and compliance log querying (filtered, paginated activity events).

Purpose: Provides the API layer that the document and compliance frontend plans depend on.
Output: Two fully functional NestJS modules registered in AppModule, ready for frontend consumption.
</objective>

<execution_context>
@C:\Users\abuba\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\abuba\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-documents-and-compliance/04-RESEARCH.md
@.planning/phases/04-documents-and-compliance/04-CONTEXT.md
@.planning/phases/04-documents-and-compliance/04-01-SUMMARY.md
@packages/database/prisma/schema.prisma
@apps/api/src/app.module.ts
@apps/api/src/timeline/timeline.service.ts
@apps/api/src/timeline/timeline.module.ts
@apps/api/src/common/config/supabase.config.ts
@apps/api/src/common/prisma/prisma.service.ts
@apps/api/src/auth/guards/jwt-auth.guard.ts
@apps/api/src/auth/decorators/current-user.decorator.ts
@apps/api/src/auth/decorators/tenant-id.decorator.ts
@apps/api/src/policies/policies.controller.ts
@apps/api/src/clients/clients.controller.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Documents NestJS module (controller, service, DTOs)</name>
  <files>
    apps/api/src/documents/documents.module.ts
    apps/api/src/documents/documents.controller.ts
    apps/api/src/documents/documents.service.ts
    apps/api/src/documents/dto/upload-document.dto.ts
    apps/api/src/documents/dto/search-documents.dto.ts
    apps/api/src/timeline/timeline.service.ts
  </files>
  <action>
**IMPORTANT PRE-FLIGHT:** Run `pnpm --filter database exec prisma generate` before starting. This ensures the Prisma client has the Document model accessor.

**1. Create `apps/api/src/documents/dto/upload-document.dto.ts`:**
A simple DTO for the non-file fields that arrive as FormData strings. Do NOT use class-validator decorators that will reject FormData strings — the service handles parsing.

```typescript
// FormData fields arrive as strings. Minimal validation here; service parses.
export class UploadDocumentDto {
  policyId?: string;
  categories?: string; // JSON string array: '["policy_document","application"]'
}
```

**2. Create `apps/api/src/documents/dto/search-documents.dto.ts`:**
Query params DTO for listing documents:

```typescript
import { IsOptional, IsString, IsUUID } from 'class-validator';

export class SearchDocumentsDto {
  @IsOptional()
  @IsUUID()
  policyId?: string;

  @IsOptional()
  @IsString()
  category?: string;
}
```

**3. Create `apps/api/src/documents/documents.service.ts`:**

The service handles:
- **uploadMany**: Upload files to Supabase Storage bucket "documents" using createSupabaseAdmin, then create Prisma Document records, then log document_uploaded activity event via TimelineService.
- **findAll**: Query Prisma documents for a client, optionally filtered by policyId and category. Include uploadedBy user name. Also return grouped structure: a list of "folders" (one per policy + "general") with document counts.
- **getSignedUrl**: Generate a signed URL (300 seconds / 5 minutes) for a document. Return the URL, mimeType, and fileName.
- **remove**: Delete from Supabase Storage, delete Prisma record, log document_deleted activity event.
- **getDocumentCounts**: Return document counts for a client (total + per policy). Used by frontend for count badges.

Storage path convention: `{tenantId}/{clientId}/{policyId || 'general'}/{uuid}-{filename}`

Use the `createSupabaseAdmin` pattern from `apps/api/src/common/config/supabase.config.ts` (same as InvitationsService).

Inject: PrismaService, TimelineService, ConfigService.

Key implementation details:
- Use `this.prisma.tenantClient.document` for tenant-scoped queries (same 'as any' pattern from Phase 2 decisions).
- For `findAll`, include `uploadedBy: { select: { firstName: true, lastName: true } }`.
- For `findAll`, also compute folder structure: group documents by policyId (null = "General" folder).
- For `uploadMany`, call `this.timelineService.createActivityEvent(tenantId, clientId, userId, 'document_uploaded', ...)`.
- For `remove`, call `this.timelineService.createActivityEvent(tenantId, clientId, userId, 'document_deleted', ...)`.
- For signed URLs, use 300 seconds (5 minutes) per research recommendation.
- Use `crypto.randomUUID()` for UUID prefix in storage paths.
- For bucket auto-creation: In the constructor, attempt to get the bucket; if it doesn't exist, create it. Wrap in try/catch so the service doesn't fail on startup. Log a warning if bucket creation fails (user may need to create it manually in Supabase Dashboard).

**4. Create `apps/api/src/documents/documents.controller.ts`:**

Controller at path `clients/:clientId/documents` with JwtAuthGuard and RolesGuard.

Endpoints:
- `POST /` — Upload. Use `@UseInterceptors(FilesInterceptor('files', 10, { limits: { fileSize: 10 * 1024 * 1024 }, fileFilter for ALLOWED_MIME_TYPES }))`. Accept `@UploadedFiles() files`, `@Body() body: UploadDocumentDto`, `@Param('clientId') clientId`, `@TenantId() tenantId`, `@CurrentUser() user`.
- `GET /` — List documents. Accept `@Query() query: SearchDocumentsDto`.
- `GET /counts` — Document counts for the client (and per-policy). Used for badges.
- `GET /:documentId/url` — Get signed URL. Accept `@Param('documentId') documentId`.
- `DELETE /:documentId` — Delete document.

All endpoints use `@Param('clientId', ParseUUIDPipe)` and `@Param('documentId', ParseUUIDPipe)` where applicable.

File filter: Check `file.mimetype` against allowed list. Reject with `BadRequestException` if not allowed.

**5. Create `apps/api/src/documents/documents.module.ts`:**

Module that provides DocumentsController and DocumentsService. Imports: TimelineModule (for TimelineService injection).

**6. Update `apps/api/src/timeline/timeline.service.ts`:**

Extend the `createActivityEvent` method signature to accept an optional `policyId` parameter. When provided, store it in the new `policyId` column on ActivityEvent (not just in metadata):

```typescript
async createActivityEvent(
  tenantId: string,
  clientId: string,
  userId: string,
  type: string,
  description: string,
  metadata?: Record<string, unknown>,
  policyId?: string, // NEW optional param
) {
  const event = await this.prisma.tenantClient.activityEvent.create({
    data: {
      clientId,
      userId,
      type: type as any,
      description,
      metadata: metadata ?? undefined,
      policyId: policyId ?? undefined, // Store if provided
    } as any,
  });
  // ... rest unchanged
}
```

This is backward-compatible — existing callers don't pass policyId and it defaults to undefined/null.
  </action>
  <verify>
Run `pnpm --filter api build` — must succeed with no type errors.
Verify the documents module files exist: controller, service, module, DTOs.
Check that TimelineService.createActivityEvent now accepts optional policyId parameter.
  </verify>
  <done>
Documents module fully implemented with upload (multi-file, Supabase Storage), list (with folder grouping), signed URL (300s), delete (storage + Prisma + activity log), and counts endpoints. TimelineService extended with optional policyId parameter. All endpoints use JwtAuthGuard + RolesGuard with tenant isolation. API builds successfully.
  </done>
</task>

<task type="auto">
  <name>Task 2: Compliance NestJS module + register both modules in AppModule</name>
  <files>
    apps/api/src/compliance/compliance.module.ts
    apps/api/src/compliance/compliance.controller.ts
    apps/api/src/compliance/compliance.service.ts
    apps/api/src/compliance/dto/search-compliance.dto.ts
    apps/api/src/app.module.ts
  </files>
  <action>
**1. Create `apps/api/src/compliance/dto/search-compliance.dto.ts`:**

```typescript
import { IsOptional, IsString, IsUUID, IsDateString } from 'class-validator';
import { Type } from 'class-transformer';

export class SearchComplianceDto {
  @IsOptional()
  @IsUUID()
  clientId?: string;

  @IsOptional()
  @IsString()
  type?: string; // ActivityEventType value

  @IsOptional()
  @IsUUID()
  userId?: string;

  @IsOptional()
  @IsUUID()
  policyId?: string;

  @IsOptional()
  @IsDateString()
  startDate?: string;

  @IsOptional()
  @IsDateString()
  endDate?: string;

  @IsOptional()
  @Type(() => Number)
  page?: number;

  @IsOptional()
  @Type(() => Number)
  limit?: number;
}
```

**2. Create `apps/api/src/compliance/compliance.service.ts`:**

The compliance service queries `ActivityEvent` with filters. It does NOT use tenantClient (compliance queries are cross-client within a tenant, and need manual tenantId in the where clause — same pattern as count() and $transaction from Phase 2 decisions).

Implementation:
- Default sort: `createdAt: 'desc'` (newest first)
- Default page: 1, default limit: 25
- Build `where` clause dynamically from provided filters
- For date range: `createdAt: { gte: new Date(startDate), lte: new Date(endDate) }`
- Include `user: { select: { firstName: true, lastName: true } }` and `client: { select: { id: true, firstName: true, lastName: true } }`
- Return: `{ data, total, page, limit, totalPages }`
- Use `Promise.all([findMany, count])` for efficient pagination

Also add a method `getActionTypes` that returns the distinct ActivityEventType values for the filter dropdown:
```typescript
async getActionTypes() {
  return [
    { value: 'policy_created', label: 'Policy Created' },
    { value: 'policy_updated', label: 'Policy Updated' },
    { value: 'policy_deleted', label: 'Policy Deleted' },
    { value: 'task_completed', label: 'Task Completed' },
    { value: 'document_uploaded', label: 'Document Uploaded' },
    { value: 'document_deleted', label: 'Document Deleted' },
    { value: 'note_added', label: 'Note Added' },
    // Include all ActivityEventType values
    { value: 'client_created', label: 'Client Created' },
    { value: 'client_updated', label: 'Client Updated' },
    { value: 'client_status_changed', label: 'Client Status Changed' },
    { value: 'task_created', label: 'Task Created' },
    { value: 'task_status_changed', label: 'Task Status Changed' },
    { value: 'policy_status_changed', label: 'Policy Status Changed' },
  ];
}
```

**3. Create `apps/api/src/compliance/compliance.controller.ts`:**

Controller at path `compliance` with JwtAuthGuard and RolesGuard.

Endpoints:
- `GET /` — List compliance events with filters. Accept `@Query() query: SearchComplianceDto`, `@TenantId() tenantId`.
- `GET /action-types` — Return available action types for filter dropdown.

Compliance log is READ-ONLY (immutable per user decision). No POST, PUT, PATCH, or DELETE endpoints.

**4. Create `apps/api/src/compliance/compliance.module.ts`:**

Module with ComplianceController and ComplianceService. No additional imports needed (PrismaService is available via PrismaModule which is already globally imported).

**5. Update `apps/api/src/app.module.ts`:**

Add both new modules to the imports array:
```typescript
import { DocumentsModule } from './documents/documents.module.js';
import { ComplianceModule } from './compliance/compliance.module.js';

// In @Module imports array, add:
DocumentsModule,
ComplianceModule,
```

After all changes, run `pnpm --filter api build` to verify everything compiles.
  </action>
  <verify>
Run `pnpm --filter api build` — must succeed with no type errors.
Run `pnpm build` from monorepo root — must succeed.
Verify AppModule imports both DocumentsModule and ComplianceModule.
Verify compliance controller has only GET endpoints (read-only, immutable).
  </verify>
  <done>
Compliance module implemented with paginated, filtered query endpoint for ActivityEvent. Action types endpoint returns all available event types for filter UI. Both DocumentsModule and ComplianceModule registered in AppModule. Full API builds successfully. Compliance log is strictly read-only (no mutation endpoints).
  </done>
</task>

</tasks>

<verification>
1. `pnpm --filter api build` passes with no errors
2. `pnpm build` (full monorepo) passes
3. Documents module has 4 endpoints: POST upload, GET list, GET signed URL, DELETE
4. Documents module has GET counts endpoint for badges
5. Compliance module has GET list (filtered) and GET action-types
6. Both modules registered in AppModule
7. TimelineService.createActivityEvent accepts optional policyId
8. Upload uses Supabase Storage via service role key (createSupabaseAdmin pattern)
9. Signed URLs use 300-second expiry
10. Document delete removes from both Supabase Storage and Prisma
</verification>

<success_criteria>
- All document CRUD operations work via REST API with tenant isolation
- Files stored in Supabase Storage at path {tenantId}/{clientId}/{policyId|general}/{uuid}-{filename}
- Document upload/delete automatically create compliance activity events
- Compliance endpoint returns paginated results with all filter options working
- Compliance log is read-only (no mutation endpoints)
- Full monorepo build passes
</success_criteria>

<output>
After completion, create `.planning/phases/04-documents-and-compliance/04-02-SUMMARY.md`
</output>
