---
phase: 04-documents-and-compliance
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - apps/api/src/documents/documents.module.ts
  - apps/api/src/documents/documents.controller.ts
  - apps/api/src/documents/documents.service.ts
  - apps/api/src/documents/dto/upload-document.dto.ts
  - apps/api/src/documents/dto/search-documents.dto.ts
  - apps/api/src/compliance/compliance.module.ts
  - apps/api/src/compliance/compliance.controller.ts
  - apps/api/src/compliance/compliance.service.ts
  - apps/api/src/compliance/dto/search-compliance.dto.ts
  - apps/api/src/app.module.ts
  - apps/api/src/timeline/timeline.service.ts
  - apps/api/src/clients/clients.service.ts
  - apps/api/src/policies/policies.service.ts
autonomous: true

must_haves:
  truths:
    - "POST /api/clients/:clientId/documents accepts multipart upload and stores files in Supabase Storage"
    - "GET /api/clients/:clientId/documents returns documents list filtered by policyId/category"
    - "GET /api/clients/:clientId/documents/:documentId/url returns a time-limited signed URL"
    - "DELETE /api/clients/:clientId/documents/:documentId removes file from storage and Prisma record"
    - "Document upload and delete automatically create activity events"
    - "GET /api/compliance returns paginated, filtered activity events across all clients"
    - "Compliance endpoint filters by clientId, type, userId, policyId, date range"
    - "All COMP-01 actions are confirmed logging activity events: policy created/updated/deleted, task completed, note added, document uploaded/deleted"
    - "Client list backend returns _count.documents for badge display"
    - "Policy list backend returns _count.documents for badge display"
  artifacts:
    - path: "apps/api/src/documents/documents.controller.ts"
      provides: "Document REST endpoints (upload, list, get URL, delete)"
      exports: ["DocumentsController"]
    - path: "apps/api/src/documents/documents.service.ts"
      provides: "Document business logic with Supabase Storage operations"
      exports: ["DocumentsService"]
    - path: "apps/api/src/compliance/compliance.controller.ts"
      provides: "Compliance query endpoint with filters"
      exports: ["ComplianceController"]
    - path: "apps/api/src/compliance/compliance.service.ts"
      provides: "Compliance query logic against ActivityEvent"
      exports: ["ComplianceService"]
  key_links:
    - from: "apps/api/src/documents/documents.service.ts"
      to: "Supabase Storage"
      via: "createSupabaseAdmin from common/config/supabase.config.js"
      pattern: "supabaseAdmin\\.storage\\.from\\('documents'\\)"
    - from: "apps/api/src/documents/documents.service.ts"
      to: "apps/api/src/timeline/timeline.service.ts"
      via: "TimelineService.createActivityEvent for document_uploaded/document_deleted"
      pattern: "timelineService\\.createActivityEvent"
    - from: "apps/api/src/compliance/compliance.service.ts"
      to: "Prisma activityEvent"
      via: "Direct Prisma query with filters"
      pattern: "prisma\\.activityEvent\\.findMany"
    - from: "apps/api/src/app.module.ts"
      to: "DocumentsModule, ComplianceModule"
      via: "Module imports array"
      pattern: "DocumentsModule|ComplianceModule"
    - from: "apps/api/src/clients/clients.service.ts"
      to: "Prisma _count.documents"
      via: "Include documents count in findAll query"
      pattern: "_count.*documents"
    - from: "apps/api/src/policies/policies.service.ts"
      to: "Prisma _count.documents"
      via: "Include documents count in findAll and findAllForTenant queries"
      pattern: "_count.*documents"
---

<objective>
Create NestJS backend modules for document management (upload, list, signed URL, delete) and compliance log querying (filtered, paginated activity events). Add document count includes to client and policy services for frontend badge display.

Purpose: Provides the API layer that the document and compliance frontend plans depend on. Ensures all COMP-01 activity event logging is in place.
Output: Two fully functional NestJS modules registered in AppModule, updated client/policy services with document counts, ready for frontend consumption.
</objective>

<execution_context>
@C:\Users\abuba\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\abuba\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-documents-and-compliance/04-RESEARCH.md
@.planning/phases/04-documents-and-compliance/04-CONTEXT.md
@.planning/phases/04-documents-and-compliance/04-01-SUMMARY.md
@packages/database/prisma/schema.prisma
@apps/api/src/app.module.ts
@apps/api/src/timeline/timeline.service.ts
@apps/api/src/timeline/timeline.module.ts
@apps/api/src/common/config/supabase.config.ts
@apps/api/src/common/prisma/prisma.service.ts
@apps/api/src/auth/guards/jwt-auth.guard.ts
@apps/api/src/auth/decorators/current-user.decorator.ts
@apps/api/src/auth/decorators/tenant-id.decorator.ts
@apps/api/src/policies/policies.controller.ts
@apps/api/src/policies/policies.service.ts
@apps/api/src/clients/clients.controller.ts
@apps/api/src/clients/clients.service.ts
@apps/api/src/tasks/tasks.service.ts
@apps/api/src/timeline/timeline.service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Documents NestJS module (controller, service, DTOs)</name>
  <files>
    apps/api/src/documents/documents.module.ts
    apps/api/src/documents/documents.controller.ts
    apps/api/src/documents/documents.service.ts
    apps/api/src/documents/dto/upload-document.dto.ts
    apps/api/src/documents/dto/search-documents.dto.ts
    apps/api/src/timeline/timeline.service.ts
  </files>
  <action>
**IMPORTANT PRE-FLIGHT:** Run `pnpm --filter database exec prisma generate` before starting. This ensures the Prisma client has the Document model accessor.

**1. Create `apps/api/src/documents/dto/upload-document.dto.ts`:**
A simple DTO for the non-file fields that arrive as FormData strings. Do NOT use class-validator decorators that will reject FormData strings -- the service handles parsing.

```typescript
// FormData fields arrive as strings. Minimal validation here; service parses.
export class UploadDocumentDto {
  policyId?: string;
  categories?: string; // JSON string array: '["policy_document","application"]'
}
```

**2. Create `apps/api/src/documents/dto/search-documents.dto.ts`:**
Query params DTO for listing documents:

```typescript
import { IsOptional, IsString, IsUUID } from 'class-validator';

export class SearchDocumentsDto {
  @IsOptional()
  @IsUUID()
  policyId?: string;

  @IsOptional()
  @IsString()
  category?: string;
}
```

**3. Create `apps/api/src/documents/documents.service.ts`:**

The service handles:
- **uploadMany**: Upload files to Supabase Storage bucket "documents" using createSupabaseAdmin, then create Prisma Document records, then log document_uploaded activity event via TimelineService.
- **findAll**: Query Prisma documents for a client, optionally filtered by policyId and category. Include uploadedBy user name. Also return grouped structure: a list of "folders" (one per policy + "general") with document counts.
- **getSignedUrl**: Generate a signed URL (300 seconds / 5 minutes) for a document. Return the URL, mimeType, and fileName.
- **remove**: Delete from Supabase Storage, delete Prisma record, log document_deleted activity event.
- **getDocumentCounts**: Return document counts for a client (total + per policy). Used by frontend for count badges.

Storage path convention: `{tenantId}/{clientId}/{policyId || 'general'}/{uuid}-{filename}`

Use the `createSupabaseAdmin` pattern from `apps/api/src/common/config/supabase.config.ts` (same as InvitationsService).

Inject: PrismaService, TimelineService, ConfigService.

Key implementation details:
- Use `this.prisma.tenantClient.document` for tenant-scoped queries (same 'as any' pattern from Phase 2 decisions).
- For `findAll`, include `uploadedBy: { select: { firstName: true, lastName: true } }`.
- For `findAll`, also compute folder structure: group documents by policyId (null = "General" folder).
- For `uploadMany`, call `this.timelineService.createActivityEvent(tenantId, clientId, userId, 'document_uploaded', ..., undefined, policyId)`. Pass the policyId as the 7th argument to the updated TimelineService method.
- For `remove`, call `this.timelineService.createActivityEvent(tenantId, clientId, userId, 'document_deleted', ..., undefined, doc.policyId)`. Pass the policyId as the 7th argument.
- For signed URLs, use 300 seconds (5 minutes) per research recommendation.
- Use `crypto.randomUUID()` for UUID prefix in storage paths.
- For bucket auto-creation: In the constructor, attempt to get the bucket; if it doesn't exist, create it. Wrap in try/catch so the service doesn't fail on startup. Log a warning if bucket creation fails (user may need to create it manually in Supabase Dashboard).

**4. Create `apps/api/src/documents/documents.controller.ts`:**

Controller at path `clients/:clientId/documents` with JwtAuthGuard and RolesGuard.

Endpoints:
- `POST /` -- Upload. Use `@UseInterceptors(FilesInterceptor('files', 10, { limits: { fileSize: 10 * 1024 * 1024 }, fileFilter for ALLOWED_MIME_TYPES }))`. Accept `@UploadedFiles() files`, `@Body() body: UploadDocumentDto`, `@Param('clientId') clientId`, `@TenantId() tenantId`, `@CurrentUser() user`.
- `GET /` -- List documents. Accept `@Query() query: SearchDocumentsDto`.
- `GET /counts` -- Document counts for the client (and per-policy). Used for badges.
- `GET /:documentId/url` -- Get signed URL. Accept `@Param('documentId') documentId`.
- `DELETE /:documentId` -- Delete document.

All endpoints use `@Param('clientId', ParseUUIDPipe)` and `@Param('documentId', ParseUUIDPipe)` where applicable.

File filter: Check `file.mimetype` against allowed list. Reject with `BadRequestException` if not allowed.

**5. Create `apps/api/src/documents/documents.module.ts`:**

Module that provides DocumentsController and DocumentsService. Imports: TimelineModule (for TimelineService injection).

**6. Update `apps/api/src/timeline/timeline.service.ts`:**

Extend the `createActivityEvent` method signature to accept an optional `policyId` parameter. When provided, store it in the new `policyId` column on ActivityEvent (not just in metadata):

```typescript
async createActivityEvent(
  tenantId: string,
  clientId: string,
  userId: string,
  type: string,
  description: string,
  metadata?: Record<string, unknown>,
  policyId?: string, // NEW optional param
) {
  const event = await this.prisma.tenantClient.activityEvent.create({
    data: {
      clientId,
      userId,
      type: type as any,
      description,
      metadata: metadata ?? undefined,
      policyId: policyId ?? undefined, // Store if provided
    } as any,
  });
  // ... rest unchanged
}
```

This is backward-compatible -- existing callers don't pass policyId and it defaults to undefined/null.
  </action>
  <verify>
Run `pnpm --filter api build` -- must succeed with no type errors.
Verify the documents module files exist: controller, service, module, DTOs.
Check that TimelineService.createActivityEvent now accepts optional policyId parameter.
Confirm documents.service.ts calls timelineService.createActivityEvent with document_uploaded and document_deleted types.
  </verify>
  <done>
Documents module fully implemented with upload (multi-file, Supabase Storage), list (with folder grouping), signed URL (300s), delete (storage + Prisma + activity log), and counts endpoints. TimelineService extended with optional policyId parameter. All endpoints use JwtAuthGuard + RolesGuard with tenant isolation. API builds successfully.
  </done>
</task>

<task type="auto">
  <name>Task 2: Compliance module + document count includes in clients/policies services + register modules + verify COMP-01 logging</name>
  <files>
    apps/api/src/compliance/compliance.module.ts
    apps/api/src/compliance/compliance.controller.ts
    apps/api/src/compliance/compliance.service.ts
    apps/api/src/compliance/dto/search-compliance.dto.ts
    apps/api/src/app.module.ts
    apps/api/src/clients/clients.service.ts
    apps/api/src/policies/policies.service.ts
  </files>
  <action>
**1. Create `apps/api/src/compliance/dto/search-compliance.dto.ts`:**

```typescript
import { IsOptional, IsString, IsUUID, IsDateString } from 'class-validator';
import { Type } from 'class-transformer';

export class SearchComplianceDto {
  @IsOptional()
  @IsUUID()
  clientId?: string;

  @IsOptional()
  @IsString()
  type?: string; // ActivityEventType value

  @IsOptional()
  @IsUUID()
  userId?: string;

  @IsOptional()
  @IsUUID()
  policyId?: string;

  @IsOptional()
  @IsDateString()
  startDate?: string;

  @IsOptional()
  @IsDateString()
  endDate?: string;

  @IsOptional()
  @Type(() => Number)
  page?: number;

  @IsOptional()
  @Type(() => Number)
  limit?: number;
}
```

**2. Create `apps/api/src/compliance/compliance.service.ts`:**

The compliance service queries `ActivityEvent` with filters. It does NOT use tenantClient (compliance queries are cross-client within a tenant, and need manual tenantId in the where clause -- same pattern as count() and $transaction from Phase 2 decisions).

Implementation:
- Default sort: `createdAt: 'desc'` (newest first)
- Default page: 1, default limit: 25
- Build `where` clause dynamically from provided filters
- For date range: `createdAt: { gte: new Date(startDate), lte: new Date(endDate) }`
- Include `user: { select: { firstName: true, lastName: true } }` and `client: { select: { id: true, firstName: true, lastName: true } }`
- Include `policy: { select: { id: true, policyNumber: true, type: true } }` for linked policy display
- Return: `{ data, total, page, limit, totalPages }`
- Use `Promise.all([findMany, count])` for efficient pagination

Also add a method `getActionTypes` that returns the distinct ActivityEventType values for the filter dropdown:
```typescript
async getActionTypes() {
  return [
    { value: 'policy_created', label: 'Policy Created' },
    { value: 'policy_updated', label: 'Policy Updated' },
    { value: 'policy_deleted', label: 'Policy Deleted' },
    { value: 'task_completed', label: 'Task Completed' },
    { value: 'document_uploaded', label: 'Document Uploaded' },
    { value: 'document_deleted', label: 'Document Deleted' },
    { value: 'note_added', label: 'Note Added' },
    // Include all ActivityEventType values
    { value: 'client_created', label: 'Client Created' },
    { value: 'client_updated', label: 'Client Updated' },
    { value: 'client_status_changed', label: 'Client Status Changed' },
    { value: 'task_created', label: 'Task Created' },
    { value: 'task_status_changed', label: 'Task Status Changed' },
    { value: 'policy_status_changed', label: 'Policy Status Changed' },
  ];
}
```

**3. Create `apps/api/src/compliance/compliance.controller.ts`:**

Controller at path `compliance` with JwtAuthGuard and RolesGuard.

Endpoints:
- `GET /` -- List compliance events with filters. Accept `@Query() query: SearchComplianceDto`, `@TenantId() tenantId`.
- `GET /action-types` -- Return available action types for filter dropdown.

Compliance log is READ-ONLY (immutable per user decision). No POST, PUT, PATCH, or DELETE endpoints.

**4. Create `apps/api/src/compliance/compliance.module.ts`:**

Module with ComplianceController and ComplianceService. No additional imports needed (PrismaService is available via PrismaModule which is already globally imported).

**5. Update `apps/api/src/app.module.ts`:**

Add both new modules to the imports array:
```typescript
import { DocumentsModule } from './documents/documents.module.js';
import { ComplianceModule } from './compliance/compliance.module.js';

// In @Module imports array, add:
DocumentsModule,
ComplianceModule,
```

**6. Update `apps/api/src/clients/clients.service.ts` -- add `_count.documents`:**

In the `findAll` method, update the `include` block to also count documents. Currently the include is:
```typescript
include: {
  _count: { select: { policies: true } },
  policies: { select: { endDate: true, status: true } },
}
```

Change the `_count` to:
```typescript
_count: { select: { policies: true, documents: true } },
```

Then in the mapping below, include the document count in the response. Currently the mapping destructures `_count` and computes `policyCount`. Add `documentCount`:
```typescript
const documentCount = client._count?.documents ?? 0;
// ... in the return:
return { ...rest, policyCount, documentCount, nextRenewalDate };
```

**7. Update `apps/api/src/policies/policies.service.ts` -- add `_count.documents`:**

In the `findAll` method (client-scoped), add `_count: { select: { documents: true } }` to the include:
```typescript
this.prisma.tenantClient.policy.findMany({
  where: { clientId },
  skip: (page - 1) * limit,
  take: limit,
  orderBy: { createdAt: 'desc' },
  include: {
    _count: { select: { documents: true } },
  },
}),
```

In the `findAllForTenant` method (cross-client), add document count to the existing include:
```typescript
include: {
  client: {
    select: { id: true, firstName: true, lastName: true },
  },
  _count: { select: { documents: true } },
},
```

**8. Verify COMP-01 activity event logging coverage:**

After building, verify that ALL auto-logged actions from the COMP-01 requirement are covered. Check each existing service file:

- `policy_created`: Logged in policies.service.ts create() -- EXISTING (uses $transaction with tx.activityEvent.create)
- `policy_updated`: Logged in policies.service.ts update() -- EXISTING (via timelineService.createActivityEvent)
- `policy_deleted`: Logged in policies.service.ts remove() -- EXISTING (via timelineService.createActivityEvent)
- `policy_status_changed`: Logged in policies.service.ts update() -- EXISTING (via timelineService.createActivityEvent)
- `task_completed` / `task_status_changed`: Logged in tasks.service.ts -- EXISTING (verify this by reading the file)
- `note_added`: Logged in timeline.service.ts createNote() -- EXISTING (via this.createActivityEvent)
- `document_uploaded`: Will be logged in documents.service.ts uploadMany() -- NEW (added in Task 1)
- `document_deleted`: Will be logged in documents.service.ts remove() -- NEW (added in Task 1)

Read `apps/api/src/tasks/tasks.service.ts` and confirm it calls `timelineService.createActivityEvent` with `task_completed` (or `task_status_changed` when status changes to completed). If the task service does NOT log task_completed events, add the logging call. The task service likely logs `task_status_changed` for all status changes -- confirm that this covers the "task completed" case (status changed to 'completed' or 'dismissed').

If any of the above are missing, add the missing `timelineService.createActivityEvent` call in the appropriate service method.

After all changes, run `pnpm --filter api build` to verify everything compiles.
  </action>
  <verify>
Run `pnpm --filter api build` -- must succeed with no type errors.
Run `pnpm build` from monorepo root -- must succeed.
Verify AppModule imports both DocumentsModule and ComplianceModule.
Verify compliance controller has only GET endpoints (read-only, immutable).
Verify clients.service.ts findAll includes `_count: { select: { policies: true, documents: true } }`.
Verify policies.service.ts findAll and findAllForTenant include `_count: { select: { documents: true } }`.
Confirm all COMP-01 actions log activity events: grep for createActivityEvent calls with types policy_created, policy_updated, policy_deleted, task_completed/task_status_changed, note_added, document_uploaded, document_deleted.
  </verify>
  <done>
Compliance module implemented with paginated, filtered query endpoint for ActivityEvent. Action types endpoint returns all available event types for filter UI. Both DocumentsModule and ComplianceModule registered in AppModule. clients.service.ts and policies.service.ts include `_count.documents` for frontend badge display. All COMP-01 activity event types confirmed logged across services. Full API builds successfully. Compliance log is strictly read-only (no mutation endpoints).
  </done>
</task>

</tasks>

<verification>
1. `pnpm --filter api build` passes with no errors
2. `pnpm build` (full monorepo) passes
3. Documents module has 4 endpoints: POST upload, GET list, GET signed URL, DELETE
4. Documents module has GET counts endpoint for badges
5. Compliance module has GET list (filtered) and GET action-types
6. Both modules registered in AppModule
7. TimelineService.createActivityEvent accepts optional policyId
8. Upload uses Supabase Storage via service role key (createSupabaseAdmin pattern)
9. Signed URLs use 300-second expiry
10. Document delete removes from both Supabase Storage and Prisma
11. clients.service.ts returns documentCount in findAll response
12. policies.service.ts returns _count.documents in findAll and findAllForTenant
13. All COMP-01 activity event types are logged (policy_created/updated/deleted, task_completed, note_added, document_uploaded/deleted)
</verification>

<success_criteria>
- All document CRUD operations work via REST API with tenant isolation
- Files stored in Supabase Storage at path {tenantId}/{clientId}/{policyId|general}/{uuid}-{filename}
- Document upload/delete automatically create compliance activity events
- Compliance endpoint returns paginated results with all filter options working
- Compliance log is read-only (no mutation endpoints)
- Client list API returns documentCount for each client
- Policy list API returns _count.documents for each policy
- All COMP-01 auto-logged actions confirmed working
- Full monorepo build passes
</success_criteria>

<output>
After completion, create `.planning/phases/04-documents-and-compliance/04-02-SUMMARY.md`
</output>
