---
phase: 04-documents-and-compliance
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/database/prisma/schema.prisma
  - packages/shared/src/types/document.ts
  - packages/shared/src/types/activity.ts
  - packages/shared/src/constants/documents.ts
  - packages/shared/src/constants/roles.ts
  - packages/shared/src/validation/document.schema.ts
  - packages/shared/src/index.ts
  - apps/web/src/lib/api.ts
  - apps/api/src/main.ts
  - apps/web/src/components/layout/nav-items.tsx
autonomous: true

must_haves:
  truths:
    - "Document model exists in Prisma schema with all required fields"
    - "DocumentCategory enum exists with 8 insurance-specific categories"
    - "ActivityEvent has policyId column and two new event types (document_uploaded, document_deleted)"
    - "Shared package exports Document types, Zod schemas, and category constants"
    - "Frontend api.ts has an upload() method for FormData"
    - "NestJS body size limit raised to handle 10MB uploads"
    - "Compliance appears in sidebar navigation instead of Documents"
  artifacts:
    - path: "packages/database/prisma/schema.prisma"
      provides: "Document model, DocumentCategory enum, ActivityEvent policyId + new types"
      contains: "model Document"
    - path: "packages/shared/src/types/document.ts"
      provides: "Document, DocumentCategory types"
      exports: ["Document", "DocumentCategory", "DocumentListItem"]
    - path: "packages/shared/src/constants/documents.ts"
      provides: "DOCUMENT_CATEGORIES, ALLOWED_MIME_TYPES, MAX_FILE_SIZE constants"
      exports: ["DOCUMENT_CATEGORIES", "ALLOWED_MIME_TYPES", "MAX_FILE_SIZE"]
    - path: "packages/shared/src/validation/document.schema.ts"
      provides: "uploadDocumentSchema, searchDocumentsSchema"
      exports: ["uploadDocumentSchema", "searchDocumentsSchema"]
    - path: "apps/web/src/lib/api.ts"
      provides: "upload() method for FormData"
      contains: "upload:"
  key_links:
    - from: "packages/database/prisma/schema.prisma"
      to: "packages/shared/src/types/document.ts"
      via: "DocumentCategory enum values must match between Prisma and shared types"
      pattern: "policy_document|application|id_license"
    - from: "packages/shared/src/types/activity.ts"
      to: "packages/database/prisma/schema.prisma"
      via: "ActivityEventType union must include document_uploaded and document_deleted"
      pattern: "document_uploaded.*document_deleted"
---

<objective>
Create the data foundation for Phase 4: Document model in Prisma, DocumentCategory enum, ActivityEvent schema extensions, shared TypeScript types/validation/constants, frontend upload helper, and body size configuration.

Purpose: All subsequent plans (backend modules, document UI, compliance UI) depend on these schema and type definitions existing.
Output: Prisma schema with Document model, shared package with document types/schemas/constants, api.ts with upload method, configured body size limits, updated NAV_ITEMS.
</objective>

<execution_context>
@C:\Users\abuba\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\abuba\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-documents-and-compliance/04-RESEARCH.md
@.planning/phases/04-documents-and-compliance/04-CONTEXT.md
@packages/database/prisma/schema.prisma
@packages/shared/src/index.ts
@packages/shared/src/types/activity.ts
@packages/shared/src/constants/roles.ts
@apps/web/src/lib/api.ts
@apps/api/src/main.ts
@apps/web/src/components/layout/nav-items.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Prisma schema -- Document model and ActivityEvent extensions</name>
  <files>
    packages/database/prisma/schema.prisma
  </files>
  <action>
Add the following to the Prisma schema:

1. **DocumentCategory enum** (place after TaskType enum):
```prisma
enum DocumentCategory {
  policy_document
  application
  id_license
  claim_form
  proof_of_insurance
  endorsement
  cancellation_notice
  correspondence

  @@map("document_category")
}
```

2. **Add two new values to ActivityEventType enum:**
Add `document_uploaded` and `document_deleted` to the existing `ActivityEventType` enum (after `task_status_changed`).

3. **Document model** (place after Note model):
```prisma
model Document {
  id            String           @id @default(uuid()) @db.Uuid
  tenantId      String           @map("tenant_id") @db.Uuid
  clientId      String           @map("client_id") @db.Uuid
  policyId      String?          @map("policy_id") @db.Uuid
  uploadedById  String           @map("uploaded_by_id") @db.Uuid
  fileName      String           @map("file_name")
  mimeType      String           @map("mime_type")
  fileSize      Int              @map("file_size")
  category      DocumentCategory @default(correspondence)
  storagePath   String           @map("storage_path")
  createdAt     DateTime         @default(now()) @map("created_at")

  tenant     Tenant  @relation(fields: [tenantId], references: [id])
  client     Client  @relation(fields: [clientId], references: [id], onDelete: Cascade)
  policy     Policy? @relation(fields: [policyId], references: [id], onDelete: SetNull)
  uploadedBy User    @relation("documentUploadedBy", fields: [uploadedById], references: [id])

  @@index([tenantId])
  @@index([clientId])
  @@index([clientId, policyId])
  @@map("documents")
}
```

CRITICAL: Use `onDelete: SetNull` on the Policy relation (NOT Cascade). Per user decision, when a policy is deleted, documents move to client level (policyId becomes null).

4. **Add relation arrays to existing models:**
- Tenant model: add `documents Document[]`
- Client model: add `documents Document[]`
- Policy model: add `documents Document[]`
- User model: add `documentsUploaded Document[] @relation("documentUploadedBy")`

5. **Extend ActivityEvent model:**
- Add optional policyId column: `policyId String? @map("policy_id") @db.Uuid`
- Add Policy relation: `policy Policy? @relation(fields: [policyId], references: [id], onDelete: SetNull)`
- Add indexes: `@@index([tenantId, type])`, `@@index([tenantId, createdAt(sort: Desc)])`, `@@index([policyId])`

6. **Add ActivityEvent relation to Policy model:**
- Add `activityEvents ActivityEvent[]` to the Policy model (needed for the relation back-reference).

After editing, run:
```bash
cd packages/database && pnpm exec prisma generate && pnpm exec prisma db push
```

If `prisma db push` fails due to the new enum values, that is unusual -- `db push` handles enum additions automatically. Check the error and resolve.
  </action>
  <verify>
Run `pnpm --filter database exec prisma generate` -- must succeed with no errors.
Run `pnpm --filter database exec prisma db push` -- must succeed (or report that the database is already in sync).
Run `pnpm --filter database exec prisma validate` -- must succeed.
  </verify>
  <done>
Prisma schema has Document model with DocumentCategory enum, ActivityEvent has policyId column and document_uploaded/document_deleted types, all relation arrays added to Tenant/Client/Policy/User, prisma generate succeeds, db push succeeds.
  </done>
</task>

<task type="auto">
  <name>Task 2: Shared types, validation, constants + api.ts upload + main.ts body limit + NAV_ITEMS</name>
  <files>
    packages/shared/src/types/document.ts
    packages/shared/src/types/activity.ts
    packages/shared/src/constants/documents.ts
    packages/shared/src/constants/roles.ts
    packages/shared/src/validation/document.schema.ts
    packages/shared/src/index.ts
    apps/web/src/lib/api.ts
    apps/api/src/main.ts
    apps/web/src/components/layout/nav-items.tsx
  </files>
  <action>
**1. Create `packages/shared/src/types/document.ts`:**

```typescript
export type DocumentCategory =
  | 'policy_document'
  | 'application'
  | 'id_license'
  | 'claim_form'
  | 'proof_of_insurance'
  | 'endorsement'
  | 'cancellation_notice'
  | 'correspondence';

export interface Document {
  id: string;
  tenantId: string;
  clientId: string;
  policyId: string | null;
  uploadedById: string;
  fileName: string;
  mimeType: string;
  fileSize: number;
  category: DocumentCategory;
  storagePath: string;
  createdAt: string;
  uploadedBy?: {
    firstName: string;
    lastName: string;
  };
}

/** Lightweight document for list views */
export interface DocumentListItem {
  id: string;
  clientId: string;
  policyId: string | null;
  fileName: string;
  mimeType: string;
  fileSize: number;
  category: DocumentCategory;
  createdAt: string;
  uploadedBy?: {
    firstName: string;
    lastName: string;
  };
}
```

**2. Update `packages/shared/src/types/activity.ts`:**

Add `'document_uploaded'` and `'document_deleted'` to the `ActivityEventType` union type. Add optional `policyId` field to `ActivityEvent` interface:

```typescript
export type ActivityEventType =
  | 'client_created'
  | 'client_updated'
  | 'client_status_changed'
  | 'note_added'
  | 'policy_created'
  | 'policy_updated'
  | 'policy_status_changed'
  | 'policy_deleted'
  | 'task_created'
  | 'task_completed'
  | 'task_status_changed'
  | 'document_uploaded'
  | 'document_deleted';
```

Add to the `ActivityEvent` interface:
```typescript
policyId?: string | null;
```

Also add optional client relation data for compliance views:
```typescript
client?: {
  id: string;
  firstName: string;
  lastName: string;
};
```

**3. Create `packages/shared/src/constants/documents.ts`:**

```typescript
import type { DocumentCategory } from '../types/document';

export const DOCUMENT_CATEGORIES: { value: DocumentCategory; label: string }[] = [
  { value: 'policy_document', label: 'Policy Document' },
  { value: 'application', label: 'Application' },
  { value: 'id_license', label: 'ID/License' },
  { value: 'claim_form', label: 'Claim Form' },
  { value: 'proof_of_insurance', label: 'Proof of Insurance' },
  { value: 'endorsement', label: 'Endorsement' },
  { value: 'cancellation_notice', label: 'Cancellation Notice' },
  { value: 'correspondence', label: 'Correspondence' },
];

export const MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB in bytes

export const ALLOWED_MIME_TYPES = [
  'application/pdf',
  'image/jpeg',
  'image/png',
  'image/gif',
  'image/webp',
  'application/msword',
  'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
];

export const ALLOWED_EXTENSIONS = '.pdf,.jpg,.jpeg,.png,.gif,.webp,.doc,.docx';
```

**4. Create `packages/shared/src/validation/document.schema.ts`:**

```typescript
import { z } from 'zod';

/** Schema for upload metadata (not the file itself -- file comes via FormData) */
export const uploadDocumentSchema = z.object({
  clientId: z.string().uuid(),
  policyId: z.string().uuid().optional(),
  category: z.enum([
    'policy_document', 'application', 'id_license', 'claim_form',
    'proof_of_insurance', 'endorsement', 'cancellation_notice', 'correspondence',
  ]).default('correspondence'),
});

export type UploadDocumentInput = z.input<typeof uploadDocumentSchema>;

export const searchDocumentsSchema = z.object({
  policyId: z.string().uuid().optional(),
  category: z.enum([
    'policy_document', 'application', 'id_license', 'claim_form',
    'proof_of_insurance', 'endorsement', 'cancellation_notice', 'correspondence',
  ]).optional(),
});

export type SearchDocumentsInput = z.input<typeof searchDocumentsSchema>;

export const searchComplianceSchema = z.object({
  clientId: z.string().uuid().optional(),
  type: z.string().optional(),
  userId: z.string().uuid().optional(),
  policyId: z.string().uuid().optional(),
  startDate: z.string().optional(),
  endDate: z.string().optional(),
  page: z.coerce.number().min(1).default(1),
  limit: z.coerce.number().min(1).max(100).default(25),
});

export type SearchComplianceInput = z.input<typeof searchComplianceSchema>;
```

**5. Update `packages/shared/src/index.ts`:**

Add exports for all new document types, constants, and validation schemas:
```typescript
// Types - Documents
export type { DocumentCategory, Document, DocumentListItem } from './types/document';

// Constants - Documents
export { DOCUMENT_CATEGORIES, MAX_FILE_SIZE, ALLOWED_MIME_TYPES, ALLOWED_EXTENSIONS } from './constants/documents';

// Validation schemas - Documents & Compliance
export { uploadDocumentSchema, searchDocumentsSchema, searchComplianceSchema } from './validation/document.schema';
export type { UploadDocumentInput, SearchDocumentsInput, SearchComplianceInput } from './validation/document.schema';
```

**6. Update `apps/web/src/lib/api.ts`:**

Add an `upload` method to the exported `api` object. This method sends FormData WITHOUT setting Content-Type (browser sets the multipart boundary automatically). Include auth headers and 401 retry logic matching the existing pattern:

```typescript
upload: async <T>(path: string, formData: FormData): Promise<T> => {
  const supabase = createClient();
  const { data: { session } } = await supabase.auth.getSession();

  const headers: Record<string, string> = {};
  if (session?.access_token) {
    headers['Authorization'] = `Bearer ${session.access_token}`;
  }
  // IMPORTANT: Do NOT set Content-Type -- browser sets it with multipart boundary

  const response = await fetch(`${API_BASE_URL}${path}`, {
    method: 'POST',
    headers,
    body: formData,
  }).catch(() => null);

  if (!response) {
    throw new Error('Unable to connect to the API server. Make sure the backend is running.');
  }

  // On 401, refresh token and retry (same pattern as request())
  if (response.status === 401) {
    await supabase.auth.getUser(); // force refresh
    const { data: { session: freshSession } } = await supabase.auth.getSession();
    const retryHeaders: Record<string, string> = {};
    if (freshSession?.access_token) {
      retryHeaders['Authorization'] = `Bearer ${freshSession.access_token}`;
    }
    const retryResponse = await fetch(`${API_BASE_URL}${path}`, {
      method: 'POST',
      headers: retryHeaders,
      body: formData,
    }).catch(() => null);

    if (!retryResponse) throw new Error('Unable to connect to the API server.');
    if (!retryResponse.ok) {
      const error = await retryResponse.json().catch(() => ({ message: `Upload failed: ${retryResponse.status}` }));
      throw new Error(error.message);
    }
    return retryResponse.json();
  }

  if (!response.ok) {
    const error = await response.json().catch(() => ({ message: `Upload failed: ${response.status}` }));
    throw new Error(error.message);
  }

  return response.json();
},
```

**7. Update `apps/api/src/main.ts`:**

Add `json` import from `express` and increase body size limit. Add AFTER `app.setGlobalPrefix('api')`:

```typescript
import { json } from 'express';
// ... in bootstrap():
app.use(json({ limit: '11mb' })); // Support 10MB file uploads + form metadata
```

Note: The Multer FileInterceptor handles the actual multipart parsing with its own limits. The `json({ limit })` is for other JSON payloads but also prevents Express from rejecting large request bodies before Multer processes them.

**8. Update `packages/shared/src/constants/roles.ts`:**

Change the Documents nav item to Compliance per user decision (no standalone /documents page; compliance page gets sidebar access):

Change:
```typescript
{ id: 'documents', label: 'Documents', href: '/documents', icon: 'FileText', adminOnly: false },
```
To:
```typescript
{ id: 'compliance', label: 'Compliance', href: '/compliance', icon: 'FileText', adminOnly: false },
```

**9. Update `apps/web/src/components/layout/nav-items.tsx`:**

The icon map already has `FileText` mapped, so no change needed to the icon map. Just verify it still works after the NAV_ITEMS label/href change. No code changes needed in this file -- the NAV_ITEMS constant change in roles.ts propagates automatically.

After all changes, run `pnpm build` from the monorepo root to verify the shared package compiles and downstream packages resolve the new exports.
  </action>
  <verify>
Run `pnpm --filter @anchor/shared build` -- must succeed.
Run `pnpm build` from monorepo root -- must succeed with no type errors.
Verify `packages/shared/src/index.ts` exports DocumentCategory, Document, DocumentListItem, DOCUMENT_CATEGORIES, MAX_FILE_SIZE, ALLOWED_MIME_TYPES, uploadDocumentSchema, searchDocumentsSchema, searchComplianceSchema.
  </verify>
  <done>
Shared package exports all document types/constants/schemas. ActivityEventType includes document_uploaded and document_deleted. api.ts has upload() method for FormData (no Content-Type header). main.ts has increased body size limit. NAV_ITEMS shows "Compliance" pointing to /compliance instead of "Documents" pointing to /documents. Full monorepo build passes.
  </done>
</task>

</tasks>

<verification>
1. `pnpm --filter database exec prisma validate` passes
2. `pnpm --filter database exec prisma generate` passes
3. `pnpm --filter @anchor/shared build` passes
4. `pnpm build` (full monorepo) passes with no type errors
5. Prisma schema has Document model with onDelete: SetNull on Policy relation
6. ActivityEventType enum has document_uploaded and document_deleted
7. ActivityEvent model has optional policyId column
8. NAV_ITEMS in roles.ts shows Compliance, not Documents
</verification>

<success_criteria>
- Document model exists in schema.prisma with all fields, indexes, and correct onDelete behaviors
- DocumentCategory enum has 8 insurance-specific values
- ActivityEvent has policyId column and 2 new event types
- Shared package builds and exports all document types, schemas, and constants
- api.ts has upload() method that sends FormData without Content-Type header
- main.ts body size limit increased for 10MB uploads
- NAV_ITEMS updated to show Compliance (/compliance) instead of Documents (/documents)
- Compliance appears in sidebar navigation instead of Documents
- Full monorepo builds successfully
</success_criteria>

<output>
After completion, create `.planning/phases/04-documents-and-compliance/04-01-SUMMARY.md`
</output>
