---
phase: 03-tasks-renewals-and-dashboard
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - apps/api/src/tasks/tasks.module.ts
  - apps/api/src/tasks/tasks.controller.ts
  - apps/api/src/tasks/tasks.service.ts
  - apps/api/src/tasks/dto/create-task.dto.ts
  - apps/api/src/tasks/dto/update-task.dto.ts
  - apps/api/src/tasks/dto/search-tasks.dto.ts
  - apps/api/src/renewals/renewals.module.ts
  - apps/api/src/renewals/renewals.service.ts
  - apps/api/src/renewals/renewals.scheduler.ts
  - apps/api/src/policies/policies.service.ts
  - apps/api/src/policies/policies.module.ts
  - apps/api/src/app.module.ts
autonomous: true

must_haves:
  truths:
    - "Tasks can be created, listed, updated, and deleted via API endpoints"
    - "Tasks are tenant-scoped and support filtering by status, priority, assignee, client, policy"
    - "Renewal tasks are auto-generated for policies with expiration dates at 60/30/7 day milestones"
    - "When policy endDate changes, pending renewal tasks are deleted and regenerated"
    - "When policy is cancelled, pending renewal tasks are auto-deleted"
    - "Duplicate renewal tasks are never created (idempotency check)"
    - "Any authenticated user can fetch the tenant assignee list (not admin-only)"
  artifacts:
    - path: "apps/api/src/tasks/tasks.controller.ts"
      provides: "Task CRUD endpoints: GET /tasks, POST /tasks, GET /tasks/:id, PATCH /tasks/:id, DELETE /tasks/:id, GET /tasks/assignees"
      exports: ["TasksController"]
    - path: "apps/api/src/tasks/tasks.service.ts"
      provides: "Task business logic with tenant scoping, search/filter/pagination"
      exports: ["TasksService"]
    - path: "apps/api/src/renewals/renewals.service.ts"
      provides: "Renewal task generation logic with idempotency, lifecycle management"
      exports: ["RenewalsService"]
    - path: "apps/api/src/renewals/renewals.scheduler.ts"
      provides: "Daily cron job for renewal task generation"
      exports: ["RenewalsScheduler"]
    - path: "apps/api/src/policies/policies.service.ts"
      provides: "Updated with renewal lifecycle hooks on endDate change and cancellation"
  key_links:
    - from: "apps/api/src/policies/policies.service.ts"
      to: "apps/api/src/renewals/renewals.service.ts"
      via: "inject and call on endDate change"
      pattern: "renewalsService\\.generateTasksForPolicy|renewalsService\\.deleteRenewalTasks"
    - from: "apps/api/src/renewals/renewals.scheduler.ts"
      to: "apps/api/src/renewals/renewals.service.ts"
      via: "@Cron decorator calls generateRenewalTasksForAllTenants"
      pattern: "@Cron.*generateRenewalTasksForAllTenants"
    - from: "apps/api/src/app.module.ts"
      to: "apps/api/src/tasks/tasks.module.ts"
      via: "module import"
      pattern: "TasksModule"
---

<objective>
Build the Task CRUD backend and Renewal automation engine. This creates the complete task API (create, list, search, update, delete with tenant scoping) and the renewal task lifecycle (auto-generation via daily cron, idempotency, policy endDate change regeneration, cancelled policy cleanup).

Purpose: Users need to manage tasks via API, and the system must auto-generate renewal tasks when policies have expiration dates. This is the core "no quiet failures" engine.
Output: TasksModule with full CRUD, RenewalsModule with cron scheduler and lifecycle hooks, updated PoliciesService with renewal integration.
</objective>

<execution_context>
@C:\Users\abuba\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\abuba\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-tasks-renewals-and-dashboard/03-CONTEXT.md
@.planning/phases/03-tasks-renewals-and-dashboard/03-RESEARCH.md
@.planning/phases/03-tasks-renewals-and-dashboard/03-01-SUMMARY.md
@apps/api/src/app.module.ts
@apps/api/src/policies/policies.service.ts
@apps/api/src/policies/policies.module.ts
@apps/api/src/policies/policies.controller.ts
@apps/api/src/clients/clients.controller.ts
@apps/api/src/common/prisma/prisma.service.ts
@apps/api/src/common/decorators/tenant-id.decorator.ts
@apps/api/src/common/decorators/current-user.decorator.ts
@apps/api/src/timeline/timeline.service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Task CRUD backend -- module, service, controller, DTOs</name>
  <files>
    apps/api/src/tasks/tasks.module.ts
    apps/api/src/tasks/tasks.controller.ts
    apps/api/src/tasks/tasks.service.ts
    apps/api/src/tasks/dto/create-task.dto.ts
    apps/api/src/tasks/dto/update-task.dto.ts
    apps/api/src/tasks/dto/search-tasks.dto.ts
    apps/api/src/app.module.ts
  </files>
  <action>
Create the Tasks module following the exact pattern of the existing Clients and Policies modules.

**DTOs (in `apps/api/src/tasks/dto/`):**

`create-task.dto.ts`: Fields matching createTaskSchema -- title (required), description, status, priority, dueDate, assigneeId, clientId, policyId. Use class-validator decorators OR plain TS class (follow existing DTO pattern in the codebase). Include optional fields.

`update-task.dto.ts`: All fields optional. Same fields as create. Plus status field for transitions.

`search-tasks.dto.ts`: Query params -- search (string, optional), status (TaskStatus, optional), priority (TaskPriority, optional), assigneeId (uuid, optional), clientId (uuid, optional), policyId (uuid, optional), type (TaskType, optional for filtering manual vs renewal), page (number, default 1), limit (number, default 20).

**Service (`apps/api/src/tasks/tasks.service.ts`):**

Inject `PrismaService` and `TimelineService`.

Methods:
- `create(tenantId, userId, dto)`: Create task. Use `tenantClient` for create. Strip empty strings to null for optional UUID fields (assigneeId, clientId, policyId) and dueDate. Convert dueDate string to Date if provided. Log `task_created` activity event if clientId is present.
- `findAll(tenantId, query)`: Search/filter/paginate. Use `tenantClient.task.findMany` with where clause built from query params. Include relations (assignee: {select: id, firstName, lastName}, client: {select: id, firstName, lastName}, policy: {select: id, type, carrier, policyNumber}). Use `this.prisma.task.count({ where: { tenantId, ...filters } })` for total (manual tenantId per Phase 2 pattern).
- `findOne(tenantId, id)`: Find single task with relations. Throw NotFoundException if not found.
- `update(tenantId, id, userId, dto)`: Update task. Strip empty strings. If status changes to 'done', log `task_completed` activity event. If status changes otherwise, log `task_status_changed`. Renewal tasks (type === 'renewal') CANNOT have title/description/dueDate edited per user decision -- only status can change. Throw BadRequestException if user tries to edit content fields on renewal tasks.
- `remove(tenantId, id, userId)`: Delete task. Throw NotFoundException if not found.
- `getAssignees(tenantId)`: Query users for the tenant: `this.prisma.user.findMany({ where: { tenantId }, select: { id: true, firstName: true, lastName: true } })`. Returns basic user info for the assignee dropdown. No admin role guard -- any authenticated user in the tenant can call this.

CRITICAL: For renewal tasks, enforce the "dismissible only" rule. The `update` method should reject changes to title, description, dueDate, priority for tasks where `type === 'renewal'`. Only status changes (mark done or reopen) are allowed.

**Controller (`apps/api/src/tasks/tasks.controller.ts`):**

Follow existing controller patterns (see ClientsController, PoliciesController).

Endpoints:
- `GET /tasks/assignees` -- return list of tenant users for assignee dropdown. NO @Roles('admin') guard -- any authenticated user can call this. **IMPORTANT: This route MUST be declared BEFORE the `GET /tasks/:id` route** so NestJS doesn't interpret "assignees" as an :id param.
- `POST /tasks` -- create task. Extract tenantId from @TenantId() decorator, userId from @CurrentUser().
- `GET /tasks` -- list/search tasks with query params. Return paginated response `{ data, total, page, limit, totalPages }`.
- `GET /tasks/:id` -- get single task with relations.
- `PATCH /tasks/:id` -- update task (status changes, field edits).
- `DELETE /tasks/:id` -- delete task.

Apply `@UseGuards(JwtAuthGuard)` to all endpoints (follow existing pattern).

**Module (`apps/api/src/tasks/tasks.module.ts`):**

Import PrismaModule. Provide TasksService, TasksController. Import TimelineModule for activity event logging.

**App Module update:**

Add `TasksModule` to imports in `app.module.ts`. Also add `ScheduleModule.forRoot()` from `@nestjs/schedule` (needed for Plan 02's renewal scheduler and Plan 03's notification scheduler).
  </action>
  <verify>
Run `pnpm --filter api build` -- should compile with no errors.
Test with curl after starting the API:
- `POST /tasks` with `{ "title": "Test task", "priority": "high" }` -- returns 201
- `GET /tasks` -- returns paginated list
- `GET /tasks?status=todo&priority=high` -- filtered results
- `GET /tasks/assignees` -- returns list of tenant users (works for both admin AND agent roles)
- `PATCH /tasks/:id` with `{ "status": "done" }` -- returns updated task
- `DELETE /tasks/:id` -- returns success
  </verify>
  <done>Task CRUD API is fully functional: create, list (with search/filter/pagination), get, update, delete. GET /tasks/assignees returns tenant users without admin role restriction. Renewal tasks reject content edits (title/description/dueDate changes). Activity events logged for task_created, task_completed, task_status_changed. ScheduleModule.forRoot() registered in AppModule.</done>
</task>

<task type="auto">
  <name>Task 2: Renewal engine -- service, scheduler, policy lifecycle hooks</name>
  <files>
    apps/api/src/renewals/renewals.module.ts
    apps/api/src/renewals/renewals.service.ts
    apps/api/src/renewals/renewals.scheduler.ts
    apps/api/src/policies/policies.service.ts
    apps/api/src/policies/policies.module.ts
    apps/api/src/app.module.ts
  </files>
  <action>
**RenewalsService (`apps/api/src/renewals/renewals.service.ts`):**

Inject `PrismaService` (NOT tenantClient -- cron jobs have no HTTP context per research pitfall #1).

Methods:
- `generateRenewalTasksForAllTenants()`: Query ALL policies across tenants where endDate is not null AND status is 'active' or 'pending_renewal'. Use raw `this.prisma.policy.findMany()` (not tenantClient). For each policy, call `generateTasksForPolicy()`.

- `generateTasksForPolicy(policy)`: For each milestone (60/30/7 days before endDate):
  1. Calculate target date: `subDays(policy.endDate, milestone.daysBefore)`
  2. Check if target date is today or in the future (skip past dates)
  3. **Idempotency check**: Query `this.prisma.task.findFirst({ where: { policyId, type: 'renewal', renewalDaysBefore: milestone.daysBefore, status: { not: 'done' } } })`. If exists, skip.
  4. Create task with: tenantId from policy, title `"Renewal: ${milestone.daysBefore}-day reminder for ${policy.type} policy"`, description including client name and expiry date, type 'renewal', priority from milestone (60d=medium, 30d=high, 7d=urgent), status 'todo', dueDate = targetDate, policyId, clientId from policy, createdById from policy.createdById, renewalDaysBefore from milestone.

  CRITICAL for task description: The `policy` parameter MUST include client relation data (firstName, lastName) for generating the task description. Callers must ensure the policy object includes `client: { firstName, lastName }`. See the note in the policy lifecycle hooks below about querying the policy fresh with includes.

  Use `RENEWAL_MILESTONES` constant from `@anchor/shared` for the 60/30/7 day configuration.

- `deleteRenewalTasksForPolicy(policyId)`: Delete all renewal tasks for a policy that are NOT done: `this.prisma.task.deleteMany({ where: { policyId, type: 'renewal', status: { not: 'done' } } })`.

- `regenerateRenewalTasks(policy)`: Call `deleteRenewalTasksForPolicy(policy.id)` then `generateTasksForPolicy(policy)`.

CRITICAL: All methods use raw `this.prisma` (not tenantClient) because this service is called from both HTTP context (policy update hooks) and cron context (no CLS). Always include explicit tenantId in queries.

**RenewalsScheduler (`apps/api/src/renewals/renewals.scheduler.ts`):**

```typescript
@Injectable()
export class RenewalsScheduler {
  private readonly logger = new Logger(RenewalsScheduler.name);
  constructor(private readonly renewalsService: RenewalsService) {}

  @Cron('0 0 1 * * *', { name: 'generate-renewal-tasks', timeZone: 'America/Toronto' })
  async handleRenewalGeneration() {
    this.logger.log('Starting daily renewal task generation...');
    try {
      await this.renewalsService.generateRenewalTasksForAllTenants();
      this.logger.log('Renewal task generation complete.');
    } catch (error) {
      this.logger.error('Renewal task generation failed', error);
    }
  }
}
```

Runs at 1:00 AM Toronto time daily. Wrapped in try/catch so failures don't crash the scheduler.

**RenewalsModule (`apps/api/src/renewals/renewals.module.ts`):**

Import PrismaModule. Provide RenewalsService and RenewalsScheduler. Export RenewalsService (needed by PoliciesModule).

**Policy lifecycle hooks -- update `apps/api/src/policies/policies.service.ts`:**

1. Inject `RenewalsService` into PoliciesService constructor.

2. In `create()` method: After the $transaction succeeds, if the created policy has an endDate, query the policy fresh with client includes: `const policyWithClient = await this.prisma.policy.findUnique({ where: { id: result.id }, include: { client: { select: { firstName: true, lastName: true } } } })`. Then call `this.renewalsService.generateTasksForPolicy(policyWithClient)`. Do NOT pass the raw transaction result directly -- it lacks client relation data needed for the task description.

3. In `update()` method: After the update succeeds, check two conditions:
   - If `dto.endDate !== undefined` and endDate actually changed from existing: query the policy fresh with client includes (same as above), then call `this.renewalsService.regenerateRenewalTasks(policyWithClient)` (delete pending + regenerate).
   - If `dto.status` changed to 'cancelled' or 'expired': call `this.renewalsService.deleteRenewalTasksForPolicy(id)`.

4. In `remove()` method: No change needed -- `onDelete: Cascade` on Task.policyId handles cleanup at the DB level.

**Update PoliciesModule:** Import RenewalsModule and add to imports array so RenewalsService can be injected into PoliciesService.

**Update AppModule:** Add `RenewalsModule` to imports.
  </action>
  <verify>
Run `pnpm --filter api build` -- should compile with no errors.
Test renewal generation manually:
1. Create a policy with endDate 30 days from now via API
2. Verify 3 renewal tasks were auto-created (60-day may be skipped if date already passed, but 30-day and 7-day should exist)
3. Check the generated task descriptions include the client name (not "undefined undefined")
4. Update the policy endDate to 60 days from now
5. Verify old renewal tasks deleted and new ones created
6. Change policy status to 'cancelled'
7. Verify all pending renewal tasks deleted
  </verify>
  <done>Renewal engine is operational: daily cron generates renewal tasks idempotently across all tenants, policy create/update/cancel triggers renewal task lifecycle management. No duplicate tasks, no orphaned tasks. Three milestones (60/30/7 days) with escalating priority (medium/high/urgent). Policy is always queried fresh with client includes before generating tasks, ensuring task descriptions contain client names.</done>
</task>

</tasks>

<verification>
1. `pnpm --filter api build` compiles cleanly
2. Task CRUD endpoints respond correctly (create, list, filter, update, delete)
3. GET /tasks/assignees returns tenant user list without admin role restriction
4. Renewal tasks auto-generate when policy with endDate is created
5. Renewal task descriptions include client name (policy queried with client includes)
6. Renewal tasks regenerate when policy endDate changes
7. Renewal tasks delete when policy is cancelled
8. Renewal task content cannot be edited (only status changes allowed)
9. Idempotency: running renewal generation twice doesn't create duplicates
</verification>

<success_criteria>
- POST/GET/PATCH/DELETE /tasks endpoints work with tenant scoping
- GET /tasks/assignees returns tenant users for any authenticated user (not admin-only)
- Task search supports status, priority, assignee, client, policy, and type filters
- Renewal tasks generated at 60/30/7 days before policy expiration with correct priorities
- Policy endDate change triggers delete+regenerate of pending renewal tasks
- Policy cancellation deletes all pending renewal tasks
- Renewal tasks enforce "dismissible only" rule (no content edits)
- Daily cron scheduled at 1 AM Toronto time
- Activity events logged for task_created, task_completed, task_status_changed
</success_criteria>

<output>
After completion, create `.planning/phases/03-tasks-renewals-and-dashboard/03-02-SUMMARY.md`
</output>
