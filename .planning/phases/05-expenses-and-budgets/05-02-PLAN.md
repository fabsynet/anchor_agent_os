---
phase: 05-expenses-and-budgets
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - apps/api/src/expenses/expenses.module.ts
  - apps/api/src/expenses/expenses.controller.ts
  - apps/api/src/expenses/expenses.service.ts
  - apps/api/src/expenses/expenses.scheduler.ts
  - apps/api/src/expenses/dto/create-expense.dto.ts
  - apps/api/src/expenses/dto/update-expense.dto.ts
  - apps/api/src/app.module.ts
autonomous: true

must_haves:
  truths:
    - "Any user can create an expense with amount, category, date, description"
    - "Users can submit expenses for admin approval (draft -> pending_approval)"
    - "Admin can approve or reject pending expenses with optional rejection note"
    - "Users can upload multiple receipt files (JPEG, PNG, WebP, PDF) to an expense"
    - "Users can download and delete receipts from their own expenses"
    - "Recurring expenses auto-create on daily cron schedule (2AM Toronto)"
    - "Only approved expenses are queryable for budget calculations"
    - "Custom categories (freeform) are supported alongside presets"
  artifacts:
    - path: "apps/api/src/expenses/expenses.module.ts"
      provides: "NestJS ExpensesModule"
      exports: ["ExpensesModule"]
    - path: "apps/api/src/expenses/expenses.controller.ts"
      provides: "CRUD + approval + receipt endpoints"
      exports: ["ExpensesController"]
    - path: "apps/api/src/expenses/expenses.service.ts"
      provides: "Expense business logic, receipt upload/download, recurring expense creation"
      exports: ["ExpensesService"]
    - path: "apps/api/src/expenses/expenses.scheduler.ts"
      provides: "Recurring expense cron job"
      exports: ["ExpensesScheduler"]
  key_links:
    - from: "apps/api/src/expenses/expenses.controller.ts"
      to: "apps/api/src/expenses/expenses.service.ts"
      via: "Controller delegates to service"
      pattern: "this\\.expensesService\\."
    - from: "apps/api/src/expenses/expenses.service.ts"
      to: "Supabase Storage (receipts bucket)"
      via: "supabaseAdmin.storage.from('receipts')"
      pattern: "storage\\.from\\('receipts'\\)"
    - from: "apps/api/src/expenses/expenses.scheduler.ts"
      to: "apps/api/src/expenses/expenses.service.ts"
      via: "Cron calls service method for all tenants"
      pattern: "createRecurringExpensesForAllTenants"
    - from: "apps/api/src/app.module.ts"
      to: "apps/api/src/expenses/expenses.module.ts"
      via: "Module import"
      pattern: "ExpensesModule"
---

<objective>
Build the Expense backend module: CRUD operations with approval workflow, receipt upload/download via Supabase Storage, status transitions (draft -> pending_approval -> approved/rejected), and a daily cron job for recurring expense auto-creation.

Purpose: This provides the complete expense management API that the frontend will consume. The approval workflow ensures only admin-approved expenses count toward budget calculations. Receipt handling reuses the Phase 4 Supabase Storage pattern.

Output: Fully functional ExpensesModule registered in AppModule with ~10 API endpoints covering expense CRUD, status transitions, receipt management, category listing, and recurring expense automation.
</objective>

<execution_context>
@C:\Users\abuba\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\abuba\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-expenses-and-budgets/05-RESEARCH.md
@.planning/phases/05-expenses-and-budgets/05-CONTEXT.md
@.planning/phases/05-expenses-and-budgets/05-01-SUMMARY.md
@packages/database/prisma/schema.prisma
@apps/api/src/app.module.ts
@apps/api/src/documents/documents.service.ts
@apps/api/src/documents/documents.controller.ts
@apps/api/src/renewals/renewals.scheduler.ts
@apps/api/src/common/prisma/prisma.service.ts
@apps/api/src/auth/jwt-auth.guard.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Expenses Service with Receipt Upload and Approval Workflow</name>
  <files>
    apps/api/src/expenses/expenses.service.ts
    apps/api/src/expenses/expenses.scheduler.ts
    apps/api/src/expenses/dto/create-expense.dto.ts
    apps/api/src/expenses/dto/update-expense.dto.ts
  </files>
  <action>
**DTOs:**
Create `create-expense.dto.ts` with class-based DTO mapping from createExpenseSchema fields: amount (number), category (string), date (string/Date), description (optional string), isRecurring (boolean, default false), recurrence (optional 'weekly'|'monthly'|'yearly').

Create `update-expense.dto.ts` with all fields optional matching updateExpenseSchema.

**ExpensesService (`expenses.service.ts`):**

Inject PrismaService and ConfigService. Create Supabase admin client same pattern as DocumentsService. Use RECEIPTS_BUCKET = 'receipts'. Auto-create bucket in constructor (same ensureBucket pattern as DocumentsService).

Implement these methods:

1. `create(tenantId, userId, dto)` -- Create expense with status 'draft', submittedById = userId. If isRecurring, calculate nextOccurrence from date + recurrence using date-fns addWeeks/addMonths/addYears.

2. `findAll(tenantId, query)` -- List expenses with pagination (page, limit, default 20). Support filters: status (optional), category (optional), dateFrom/dateTo (optional). Include receipts[] and submittedBy (select id, firstName, lastName). Order by date DESC, createdAt DESC. Use raw `this.prisma` with manual tenantId (count() is not in tenant extension).

3. `findOne(tenantId, expenseId)` -- Get single expense with receipts and submittedBy/approvedBy. Throw NotFoundException if not found or wrong tenant.

4. `update(tenantId, userId, expenseId, dto)` -- Update expense. Only allow if status is 'draft' or 'rejected' (throw BadRequestException otherwise -- "Cannot edit an expense that is pending approval or already approved"). If editing a rejected expense, reset status to 'draft'.

5. `delete(tenantId, userId, expenseId)` -- Delete expense. Only allow if status is 'draft' or 'rejected'. Also delete receipts from Supabase Storage. Use onDelete: Cascade for DB records.

6. `submit(tenantId, userId, expenseId)` -- Change status from 'draft' to 'pending_approval'. Throw if not draft.

7. `approve(tenantId, adminUserId, expenseId)` -- Change status to 'approved', set approvedById and approvedAt. Throw if not pending_approval. Return the approved expense (caller -- budgets service -- will use this to trigger threshold check).

8. `reject(tenantId, adminUserId, expenseId, rejectionNote?: string)` -- Change status to 'rejected', set rejectionNote. Throw if not pending_approval.

9. `uploadReceipts(tenantId, expenseId, files: Express.Multer.File[])` -- For each file: validate mime type against RECEIPT_ALLOWED_MIME_TYPES, validate size against RECEIPT_MAX_FILE_SIZE, generate UUID prefix, upload to `${tenantId}/expenses/${expenseId}/${uuid}-${originalname}`, create ExpenseReceipt record. Use raw `this.prisma` with tenantId for creating receipts (tenant extension may not work cleanly with nested relations).

10. `getReceiptSignedUrl(tenantId, receiptId)` -- Get ExpenseReceipt, validate tenantId, return signed URL (60 min expiry) from Supabase Storage.

11. `deleteReceipt(tenantId, receiptId)` -- Delete from Storage and DB. Validate tenant ownership.

12. `getCategories(tenantId)` -- Return EXPENSE_CATEGORIES presets merged with any custom categories used by this tenant. Query `SELECT DISTINCT category FROM expenses WHERE tenant_id = $1` via Prisma `findMany` with `distinct: ['category']`, then merge with preset list. Return combined unique list.

13. `getPendingCount(tenantId)` -- Count expenses with status 'pending_approval' for nav badge. Use raw `this.prisma.expense.count()` with manual tenantId.

14. `createRecurringExpensesForAllTenants()` -- Called by cron. Use raw `this.prisma` (no CLS context). Find all expenses where isRecurring=true AND nextOccurrence <= today. For each: create a new child expense (parentExpenseId set, status='draft', same amount/category/description, date=nextOccurrence). Advance parent's nextOccurrence using date-fns addWeeks/addMonths/addYears based on recurrence. Use $transaction per tenant for atomicity. Log counts.

**ExpensesScheduler (`expenses.scheduler.ts`):**
Follow RenewalsScheduler pattern exactly. Inject ExpensesService. Single @Cron method at '0 0 2 * * *' (2AM Toronto time). Calls `this.expensesService.createRecurringExpensesForAllTenants()`. Wrap in try/catch with Logger.

**CRITICAL PATTERNS:**
- Use `this.prisma` (raw) for count(), aggregate(), and cron methods -- NOT tenantClient (per established decision)
- Use `as any` for Prisma create/update data when using tenant extension (per established decision)
- Amounts stored as Decimal(12,2) in DB, serialized as strings in responses
- Receipt storage paths: `${tenantId}/expenses/${expenseId}/${uuid}-${filename}`
- Status transitions are strict: draft->pending_approval->approved/rejected, rejected->draft (on edit)
  </action>
  <verify>
Run `pnpm --filter api build` -- should compile without errors.
Verify all 14 service methods exist in the compiled output.
Check that the scheduler has the @Cron decorator with correct timezone.
  </verify>
  <done>
ExpensesService has all 14 methods covering CRUD, approval workflow, receipt upload/download/delete, category listing, and recurring expense automation. ExpensesScheduler runs daily at 2AM Toronto time. All methods follow established patterns (raw prisma for aggregates, tenant extension for CRUD, Supabase Storage for files).
  </done>
</task>

<task type="auto">
  <name>Task 2: Expenses Controller and Module Registration</name>
  <files>
    apps/api/src/expenses/expenses.controller.ts
    apps/api/src/expenses/expenses.module.ts
    apps/api/src/app.module.ts
  </files>
  <action>
**ExpensesController (`expenses.controller.ts`):**

Use @Controller('api/expenses') and @UseGuards(JwtAuthGuard) on the class.

Endpoints (follow existing controller patterns from DocumentsController and TasksController):

1. `POST /api/expenses` -- Create expense. Extract tenantId and userId from @Req(). Body: CreateExpenseDto. Returns 201 with created expense.

2. `GET /api/expenses` -- List expenses. Query params: page (default 1), limit (default 20), status (optional), category (optional), dateFrom (optional), dateTo (optional). Returns `{ data: Expense[], total: number, page: number, limit: number }`.

3. `GET /api/expenses/categories` -- Get preset + custom categories for this tenant. Returns `{ value: string; label: string }[]`.

4. `GET /api/expenses/pending-count` -- Get count of pending_approval expenses. Returns `{ count: number }`. (Used for nav badge.)

5. `GET /api/expenses/:id` -- Get single expense with receipts. Returns expense.

6. `PATCH /api/expenses/:id` -- Update expense. Body: UpdateExpenseDto. Only works for draft/rejected expenses.

7. `DELETE /api/expenses/:id` -- Delete expense. Only works for draft/rejected expenses.

8. `POST /api/expenses/:id/submit` -- Submit expense for approval. Changes status to pending_approval.

9. `POST /api/expenses/:id/approve` -- Admin-only. Approve expense. Check user.role === 'admin', throw ForbiddenException otherwise.

10. `POST /api/expenses/:id/reject` -- Admin-only. Reject expense. Body: { rejectionNote?: string }.

11. `POST /api/expenses/:id/receipts` -- Upload receipts. Use @UseInterceptors(FilesInterceptor('files', 5)) for up to 5 files at once. Delegates to service.uploadReceipts.

12. `GET /api/expenses/receipts/:receiptId/url` -- Get signed download URL for a receipt.

13. `DELETE /api/expenses/receipts/:receiptId` -- Delete a receipt.

**Admin guard pattern for approve/reject:** Check `req.user.role === 'admin'` at the start of the method and throw `new ForbiddenException('Only admins can approve/reject expenses')`. Do NOT create a separate guard -- inline check matches existing pattern (e.g., compliance user filter).

**Multer setup:** Import `FilesInterceptor` from `@nestjs/platform-express`. The express body limit is already 11mb from Phase 4. Multer handles multipart parsing.

**ExpensesModule (`expenses.module.ts`):**
Import and provide: ExpensesService, ExpensesScheduler. Export ExpensesService (needed by BudgetsModule for threshold check on approve). Register controller: ExpensesController. Import MulterModule.register() if needed (or rely on interceptor-level config).

**Register in AppModule (`app.module.ts`):**
Add `ExpensesModule` to imports array.

**CRITICAL:** The approve endpoint must return the approved expense so that the caller (in Plan 03, BudgetsService) can check budget thresholds after approval. For now, just return the expense. The integration with BudgetsService will happen in Plan 03 via event or direct call.
  </action>
  <verify>
Run `pnpm --filter api build` -- should compile without errors.
Verify all 13 endpoints are registered (check controller decorators).
Verify ExpensesModule is imported in AppModule.
Start the API briefly (`pnpm --filter api dev` for 10 seconds) and check logs for "ExpensesModule" initialization and "receipts" bucket check.
  </verify>
  <done>
ExpensesController has 13 endpoints covering all expense operations. ExpensesModule is registered in AppModule. Admin-only endpoints (approve/reject) check user role inline. Receipt upload uses FilesInterceptor with max 5 files. ExpensesService is exported from the module for cross-module use by BudgetsModule.
  </done>
</task>

</tasks>

<verification>
- `pnpm --filter api build` passes with no errors
- All 13 API endpoints are accessible (controller decorators present)
- Approval workflow enforces status transitions correctly
- Receipt upload uses Supabase Storage 'receipts' bucket with UUID-prefixed paths
- Recurring expense cron is registered at 2AM Toronto time
- ExpensesModule exports ExpensesService for cross-module use
- Admin-only checks on approve/reject endpoints
</verification>

<success_criteria>
- Complete expense CRUD with draft/pending_approval/approved/rejected status flow
- Multiple receipt upload/download/delete via Supabase Storage
- Recurring expense cron creates child expenses with advanced nextOccurrence
- Custom categories queryable alongside presets
- Pending count endpoint for nav badge
- API builds and starts without errors
</success_criteria>

<output>
After completion, create `.planning/phases/05-expenses-and-budgets/05-02-SUMMARY.md`
</output>
