---
phase: 05-expenses-and-budgets
plan: 03
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - apps/api/src/budgets/budgets.module.ts
  - apps/api/src/budgets/budgets.controller.ts
  - apps/api/src/budgets/budgets.service.ts
  - apps/api/src/budgets/budgets.scheduler.ts
  - apps/api/src/budgets/dto/create-budget.dto.ts
  - apps/api/src/budgets/dto/update-budget.dto.ts
  - apps/api/src/alerts/alerts.module.ts
  - apps/api/src/alerts/alerts.controller.ts
  - apps/api/src/alerts/alerts.service.ts
  - apps/api/src/dashboard/dashboard.controller.ts
  - apps/api/src/dashboard/dashboard.service.ts
  - apps/api/src/app.module.ts
autonomous: true

must_haves:
  truths:
    - "Admin can create a monthly budget with overall limit and per-category limits"
    - "Admin can edit and delete budgets"
    - "Team members can view but not modify budgets"
    - "Budgets auto-renew on the 1st of each month with same limits carried forward"
    - "System creates in-app notification when approved spending reaches 80% of a budget category"
    - "Dashboard financial endpoint returns total spent, expense count, top category, budget usage, and per-category breakdown"
    - "In-app notifications can be listed and marked as read"
    - "Budget threshold alerts are idempotent (no duplicate alerts for same threshold)"
  artifacts:
    - path: "apps/api/src/budgets/budgets.service.ts"
      provides: "Budget CRUD, threshold check, spending summary"
      exports: ["BudgetsService"]
    - path: "apps/api/src/budgets/budgets.scheduler.ts"
      provides: "Monthly auto-renewal cron job"
      exports: ["BudgetsScheduler"]
    - path: "apps/api/src/alerts/alerts.service.ts"
      provides: "In-app notification CRUD, unread count"
      exports: ["AlertsService"]
    - path: "apps/api/src/dashboard/dashboard.service.ts"
      provides: "Financial dashboard data endpoint"
      exports: ["DashboardService"]
  key_links:
    - from: "apps/api/src/budgets/budgets.service.ts"
      to: "apps/api/src/alerts/alerts.service.ts"
      via: "Threshold check creates notification via AlertsService"
      pattern: "alertsService\\.create"
    - from: "apps/api/src/budgets/budgets.scheduler.ts"
      to: "apps/api/src/budgets/budgets.service.ts"
      via: "Cron calls service for auto-renewal"
      pattern: "autoRenewBudgetsForAllTenants"
    - from: "apps/api/src/dashboard/dashboard.service.ts"
      to: "prisma.expense"
      via: "Aggregates approved expenses for financial widget"
      pattern: "status.*approved"
---

<objective>
Build the Budget management backend, in-app Alerts system, and Dashboard financial endpoint. Budgets track monthly spending limits (overall + per-category), auto-renew monthly, and trigger in-app alerts at 80% threshold. The dashboard financial endpoint provides the data for the frontend financial widget.

Purpose: This completes the financial backend -- budget management with auto-renewal, spending threshold alerts, and the dashboard data source. Combined with Plan 02 (expenses), this gives the frontend everything it needs to render expense and budget UIs.

Output: BudgetsModule (CRUD + auto-renewal cron + threshold checking), AlertsModule (in-app notification CRUD), and an updated DashboardService with a financial data endpoint.
</objective>

<execution_context>
@C:\Users\abuba\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\abuba\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-expenses-and-budgets/05-RESEARCH.md
@.planning/phases/05-expenses-and-budgets/05-CONTEXT.md
@.planning/phases/05-expenses-and-budgets/05-01-SUMMARY.md
@packages/database/prisma/schema.prisma
@apps/api/src/app.module.ts
@apps/api/src/dashboard/dashboard.service.ts
@apps/api/src/dashboard/dashboard.controller.ts
@apps/api/src/dashboard/dashboard.module.ts
@apps/api/src/renewals/renewals.scheduler.ts
@apps/api/src/common/prisma/prisma.service.ts
@apps/api/src/auth/jwt-auth.guard.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Alerts Service and Budgets Service with Threshold Checking</name>
  <files>
    apps/api/src/alerts/alerts.module.ts
    apps/api/src/alerts/alerts.controller.ts
    apps/api/src/alerts/alerts.service.ts
    apps/api/src/budgets/budgets.service.ts
    apps/api/src/budgets/budgets.scheduler.ts
    apps/api/src/budgets/dto/create-budget.dto.ts
    apps/api/src/budgets/dto/update-budget.dto.ts
  </files>
  <action>
**AlertsService (`alerts.service.ts`):**
Inject PrismaService. Methods:

1. `create(tenantId, userId, data: { type: string; title: string; message: string; metadata?: any })` -- Create InAppNotification record. Use raw `this.prisma` with manual tenantId.

2. `findAll(tenantId, userId, query: { unreadOnly?: boolean; limit?: number })` -- List notifications for user. Default limit 20. Order by createdAt DESC. Use raw `this.prisma` with manual tenantId + userId.

3. `getUnreadCount(tenantId, userId)` -- Count unread notifications. Use raw `this.prisma.inAppNotification.count()`.

4. `markAsRead(tenantId, userId, notificationId)` -- Set isRead = true. Validate ownership.

5. `markAllAsRead(tenantId, userId)` -- Set isRead = true for all user's notifications. Use `updateMany`.

6. `hasExistingAlert(tenantId, type: string, metadata: Record<string, unknown>)` -- Check if an alert with the same type and matching metadata already exists (for idempotent threshold alerts). Query by type and JSON metadata match. This prevents duplicate "80% budget warning" alerts for the same budget+category+month.

**AlertsController (`alerts.controller.ts`):**
@Controller('api/alerts'), @UseGuards(JwtAuthGuard).
1. `GET /api/alerts` -- List notifications. Query: unreadOnly (boolean), limit (number).
2. `GET /api/alerts/unread-count` -- Get unread count. Returns `{ count: number }`.
3. `PATCH /api/alerts/:id/read` -- Mark single as read.
4. `POST /api/alerts/mark-all-read` -- Mark all as read.

**AlertsModule (`alerts.module.ts`):**
Provide AlertsService, AlertsController. Export AlertsService (needed by BudgetsService).

---

**Budget DTOs:**
`create-budget.dto.ts`: month (number), year (number), totalLimit (number), categories (optional array of { category: string, limitAmount: number }).
`update-budget.dto.ts`: totalLimit (optional number), categories (optional array).

**BudgetsService (`budgets.service.ts`):**
Inject PrismaService and AlertsService. Methods:

1. `create(tenantId, userId, dto)` -- Create budget with BudgetCategory children in a $transaction. Check @@unique([tenantId, month, year]) by catching Prisma unique constraint error or checking first. Use raw `this.prisma` for the $transaction (tenant extension doesn't handle $transaction). Set isActive = true, createdById = userId.

2. `findAll(tenantId)` -- List all budgets ordered by year DESC, month DESC. Include categories. Use tenant extension findMany.

3. `findOne(tenantId, budgetId)` -- Get single budget with categories. Validate tenantId.

4. `findCurrentMonth(tenantId)` -- Find budget for current month/year. Return null if none exists.

5. `update(tenantId, budgetId, dto)` -- Update totalLimit and/or categories. Admin check done in controller. For categories: delete existing BudgetCategories and recreate (simpler than diffing). Use $transaction with raw `this.prisma`.

6. `delete(tenantId, budgetId)` -- Delete budget. onDelete: Cascade handles BudgetCategories.

7. `getSpendingSummary(tenantId, month, year)` -- Calculate total approved spending for a given month. Query: `this.prisma.expense.aggregate()` where tenantId, status='approved', date between startOfMonth and endOfMonth. Also group by category using `this.prisma.expense.groupBy()`. CRITICAL: use raw `this.prisma` for aggregate/groupBy (not tenant extension). CRITICAL: filter by `status: 'approved'` -- only approved expenses count. Return `{ totalSpent: number, byCategory: { category: string, spent: number }[] }`.

8. `checkBudgetThreshold(tenantId, category: string, month: number, year: number)` -- Called after an expense is approved. Get budget for month/year. Get spending for that category in that month. Check against per-category limit (if exists) AND overall total. If spending >= 80% of either limit, check if alert already exists via `alertsService.hasExistingAlert()`. If no existing alert, create InAppNotification for ALL admin users in the tenant (find users with role='admin'). Alert type = 'budget_warning'. Metadata includes: `{ budgetId, category, month, year, spent, limit, percentage }`.

9. `autoRenewBudgetsForAllTenants()` -- Called by cron. Use raw `this.prisma`. Find all active budgets for PREVIOUS month (current month - 1). For each: set isActive = false. Check if budget for CURRENT month already exists (unique constraint). If not, create new budget with same totalLimit and same category limits. Log counts per tenant.

**BudgetsScheduler (`budgets.scheduler.ts`):**
Follow RenewalsScheduler pattern. Inject BudgetsService. @Cron at '0 0 0 1 * *' (midnight 1st of month, Toronto time). Calls `autoRenewBudgetsForAllTenants()`. Wrap in try/catch with Logger.

**CRITICAL PATTERNS:**
- ALL aggregate/count/groupBy queries use raw `this.prisma` with manual tenantId
- Budget calculations MUST filter `status: 'approved'` -- draft/pending/rejected expenses DO NOT count
- Threshold check is idempotent -- check hasExistingAlert before creating
- Use date-fns `startOfMonth`, `endOfMonth` for month boundary queries
- Cron uses raw `this.prisma` (no CLS context)
  </action>
  <verify>
Run `pnpm --filter api build` -- should compile without errors.
Verify AlertsService has 6 methods.
Verify BudgetsService has 9 methods.
Verify BudgetsScheduler has @Cron decorator with '0 0 0 1 * *' and America/Toronto timezone.
  </verify>
  <done>
AlertsService provides in-app notification CRUD with idempotent alert checking. BudgetsService provides budget CRUD, spending summary aggregation (approved-only), threshold checking at 80%, and auto-renewal logic. BudgetsScheduler runs monthly on the 1st. All aggregation queries use raw prisma with manual tenantId.
  </done>
</task>

<task type="auto">
  <name>Task 2: Budgets Controller, Dashboard Financial Endpoint, and Module Registration</name>
  <files>
    apps/api/src/budgets/budgets.module.ts
    apps/api/src/budgets/budgets.controller.ts
    apps/api/src/dashboard/dashboard.controller.ts
    apps/api/src/dashboard/dashboard.service.ts
    apps/api/src/dashboard/dashboard.module.ts
    apps/api/src/app.module.ts
  </files>
  <action>
**BudgetsController (`budgets.controller.ts`):**
@Controller('api/budgets'), @UseGuards(JwtAuthGuard).

1. `POST /api/budgets` -- Admin-only. Create budget. Check user.role === 'admin', throw ForbiddenException otherwise. Body: CreateBudgetDto.

2. `GET /api/budgets` -- List all budgets. Available to all authenticated users (team members can view per user decision).

3. `GET /api/budgets/current` -- Get current month's budget with spending summary. Returns budget + spending data merged. Available to all.

4. `GET /api/budgets/:id` -- Get single budget with categories.

5. `PATCH /api/budgets/:id` -- Admin-only. Update budget.

6. `DELETE /api/budgets/:id` -- Admin-only. Delete budget.

**BudgetsModule (`budgets.module.ts`):**
Import AlertsModule. Provide BudgetsService, BudgetsScheduler. Register BudgetsController. Export BudgetsService.

---

**Dashboard Financial Endpoint:**

Add to existing DashboardService a new method `getFinancialSummary(tenantId)`:
- Get current month's budget via BudgetsService (or null if none)
- Get spending summary for current month via BudgetsService.getSpendingSummary()
- Calculate: totalSpent, expenseCount (count of approved expenses this month), topCategory (category with highest spend), budgetTotal (overall limit or null), budgetUsedPercentage (totalSpent / budgetTotal * 100 or null)
- Per-category breakdown: merge budget category limits with actual spending. For each category in spending OR budget categories, return `{ name: string, spent: number, limit: number | null, percentage: number }`.
- Return the full FinancialSummary object.

IMPORTANT: This method needs access to BudgetsService. Update DashboardModule to import BudgetsModule. Inject BudgetsService into DashboardService.

Add to existing DashboardController:
`GET /api/dashboard/financial` -- Returns financial summary. Check access: user.role === 'admin' OR user.canViewFinancials === true. If neither, return 403 Forbidden. Query user's canViewFinancials from DB: `this.prisma.user.findUnique({ where: { id: userId }, select: { canViewFinancials: true } })`.

NOTE: The `canViewFinancials` field is on the User model but may NOT be on the AuthenticatedUser interface in the guard. So query it from the DB in the controller/service.

---

**Update DashboardModule (`dashboard.module.ts`):**
Import BudgetsModule. The BudgetsModule exports BudgetsService so DashboardService can inject it.

**Register in AppModule (`app.module.ts`):**
Add `BudgetsModule` and `AlertsModule` to imports array. (ExpensesModule was added in Plan 02.)

**Wire threshold check to expense approval:**
The ideal flow is: ExpensesController.approve() -> ExpensesService.approve() returns approved expense -> controller calls BudgetsService.checkBudgetThreshold(). However, Plan 02 and Plan 03 run in parallel. Two options:
- Option A: Put the threshold call in ExpensesController.approve() -- but this creates a dependency on BudgetsService which is in Plan 03.
- Option B: Create the wiring in THIS plan by modifying ExpensesController.approve() to call BudgetsService after approval.

**Go with Option B:** After Plan 02 creates the ExpensesModule, modify `expenses.controller.ts` to inject BudgetsService and call `checkBudgetThreshold` after a successful approval. Import BudgetsModule in ExpensesModule. Update `ExpensesModule` to import `BudgetsModule`. In `ExpensesController.approve()`, after calling `this.expensesService.approve()`, call:
```typescript
// Trigger budget threshold check (fire-and-forget)
this.budgetsService.checkBudgetThreshold(
  tenantId, expense.category,
  new Date(expense.date).getMonth() + 1,
  new Date(expense.date).getFullYear()
).catch(err => this.logger.warn('Budget threshold check failed', err));
```

This is safe because the threshold check is idempotent and non-blocking.
  </action>
  <verify>
Run `pnpm --filter api build` -- should compile without errors.
Verify BudgetsController has 6 endpoints.
Verify `GET /api/dashboard/financial` endpoint exists with access control.
Verify BudgetsModule and AlertsModule are imported in AppModule.
Verify ExpensesController.approve() calls BudgetsService.checkBudgetThreshold().
Start API briefly and check for "BudgetsModule" and "AlertsModule" initialization in logs.
  </verify>
  <done>
BudgetsController has 6 endpoints (CRUD + current month). Dashboard has /api/dashboard/financial endpoint with admin/canViewFinancials access control. AlertsModule and BudgetsModule registered in AppModule. Expense approval triggers budget threshold check. Budget auto-renewal cron runs on 1st of month.
  </done>
</task>

</tasks>

<verification>
- `pnpm --filter api build` passes with no errors
- Budget CRUD endpoints enforce admin-only for mutations, allow all for reads
- Dashboard financial endpoint checks canViewFinancials for non-admin users
- Threshold check creates idempotent in-app notifications at 80%
- Budget auto-renewal cron registered for 1st of month
- Expense approval triggers threshold check (wired cross-module)
- All aggregate queries filter by status: 'approved'
</verification>

<success_criteria>
- Admin can create/edit/delete budgets with overall + per-category limits
- Spending summary correctly aggregates only approved expenses
- 80% threshold creates in-app notification for admin users
- Dashboard financial endpoint returns complete data for widget
- Budgets auto-renew monthly with same limits
- Alerts system supports CRUD and unread count
</success_criteria>

<output>
After completion, create `.planning/phases/05-expenses-and-budgets/05-03-SUMMARY.md`
</output>
